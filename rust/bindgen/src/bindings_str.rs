
// WARNING: FILE CODE GENERATED BY BINDGEN UTILITY. DO NOT EDIT!
use crate::call_wasm_export::call_wasm_export;
use crate::serialize::{BufferDeserializer, NumberDeserializer, VectorDeserializer, BoolDeserializer};
use crate::types::{Fr, Fq, Point, Buffer32, Buffer128};

pub fn pedersen_init()-> Result<(), Box<dyn std::error::Error>> {
    let in_args = vec![];
    let out_types = vec![];
    let result = call_wasm_export(&"pedersen_init", &in_args, &out_types)?;
    Ok(())
}

pub fn pedersen_compress_fields(left: Fr, right: Fr)-> Result<(Fr), Box<dyn std::error::Error>> {
    let in_args = vec![left, right];
    let out_types = vec![Fr];
    let result = call_wasm_export(&"pedersen_compress_fields", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn pedersen_plookup_compress_fields(left: Fr, right: Fr)-> Result<(Fr), Box<dyn std::error::Error>> {
    let in_args = vec![left, right];
    let out_types = vec![Fr];
    let result = call_wasm_export(&"pedersen_plookup_compress_fields", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn pedersen_compress(inputs_buffer: Fr[])-> Result<(Fr), Box<dyn std::error::Error>> {
    let in_args = vec![inputs_buffer];
    let out_types = vec![Fr];
    let result = call_wasm_export(&"pedersen_compress", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn pedersen_plookup_compress(inputs_buffer: Fr[])-> Result<(Fr), Box<dyn std::error::Error>> {
    let in_args = vec![inputs_buffer];
    let out_types = vec![Fr];
    let result = call_wasm_export(&"pedersen_plookup_compress", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn pedersen_compress_with_hash_index(inputs_buffer: Fr[], hash_index: number)-> Result<(Fr), Box<dyn std::error::Error>> {
    let in_args = vec![inputs_buffer, hash_index];
    let out_types = vec![Fr];
    let result = call_wasm_export(&"pedersen_compress_with_hash_index", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn pedersen_commit(inputs_buffer: Fr[])-> Result<(Fr), Box<dyn std::error::Error>> {
    let in_args = vec![inputs_buffer];
    let out_types = vec![Fr];
    let result = call_wasm_export(&"pedersen_commit", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn pedersen_plookup_commit(inputs_buffer: Fr[])-> Result<(Fr), Box<dyn std::error::Error>> {
    let in_args = vec![inputs_buffer];
    let out_types = vec![Fr];
    let result = call_wasm_export(&"pedersen_plookup_commit", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn pedersen_buffer_to_field(data: Buffer)-> Result<(Fr), Box<dyn std::error::Error>> {
    let in_args = vec![data];
    let out_types = vec![Fr];
    let result = call_wasm_export(&"pedersen_buffer_to_field", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn pedersen_hash_init()-> Result<(), Box<dyn std::error::Error>> {
    let in_args = vec![];
    let out_types = vec![];
    let result = call_wasm_export(&"pedersen_hash_init", &in_args, &out_types)?;
    Ok(())
}

pub fn pedersen_hash_pair(left: Fr, right: Fr)-> Result<(Fr), Box<dyn std::error::Error>> {
    let in_args = vec![left, right];
    let out_types = vec![Fr];
    let result = call_wasm_export(&"pedersen_hash_pair", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn pedersen_hash_multiple(inputs_buffer: Fr[])-> Result<(Fr), Box<dyn std::error::Error>> {
    let in_args = vec![inputs_buffer];
    let out_types = vec![Fr];
    let result = call_wasm_export(&"pedersen_hash_multiple", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn pedersen_hash_multiple_with_hash_index(inputs_buffer: Fr[], hash_index: number)-> Result<(Fr), Box<dyn std::error::Error>> {
    let in_args = vec![inputs_buffer, hash_index];
    let out_types = vec![Fr];
    let result = call_wasm_export(&"pedersen_hash_multiple_with_hash_index", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn pedersen_hash_to_tree(data: Fr[])-> Result<(Fr[]), Box<dyn std::error::Error>> {
    let in_args = vec![data];
    let out_types = vec![VectorDeserializer(Fr)];
    let result = call_wasm_export(&"pedersen_hash_to_tree", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn blake2s(data: Buffer)-> Result<(Buffer32), Box<dyn std::error::Error>> {
    let in_args = vec![data];
    let out_types = vec![Buffer32];
    let result = call_wasm_export(&"blake2s", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn blake2s_to_field(data: Buffer)-> Result<(Fr), Box<dyn std::error::Error>> {
    let in_args = vec![data];
    let out_types = vec![Fr];
    let result = call_wasm_export(&"blake2s_to_field", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn schnorr_compute_public_key(private_key: Fr)-> Result<(Point), Box<dyn std::error::Error>> {
    let in_args = vec![private_key];
    let out_types = vec![Point];
    let result = call_wasm_export(&"schnorr_compute_public_key", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn schnorr_negate_public_key(public_key_buffer: Point)-> Result<(Point), Box<dyn std::error::Error>> {
    let in_args = vec![public_key_buffer];
    let out_types = vec![Point];
    let result = call_wasm_export(&"schnorr_negate_public_key", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn schnorr_construct_signature(message: Buffer, private_key: Fr)-> Result<(Buffer32, Buffer32), Box<dyn std::error::Error>> {
    let in_args = vec![message, private_key];
    let out_types = vec![Buffer32, Buffer32];
    let result = call_wasm_export(&"schnorr_construct_signature", &in_args, &out_types)?;
    Ok((result[0].clone(), result[1].clone()))
}

pub fn schnorr_verify_signature(message: Buffer, pub_key: Point, sig_s: Buffer32, sig_e: Buffer32)-> Result<(boolean), Box<dyn std::error::Error>> {
    let in_args = vec![message, pub_key, sig_s, sig_e];
    let out_types = vec![BoolDeserializer()];
    let result = call_wasm_export(&"schnorr_verify_signature", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn schnorr_multisig_create_multisig_public_key(private_key: Fq)-> Result<(Buffer128), Box<dyn std::error::Error>> {
    let in_args = vec![private_key];
    let out_types = vec![Buffer128];
    let result = call_wasm_export(&"schnorr_multisig_create_multisig_public_key", &in_args, &out_types)?;
    Ok(result[0].clone())
}

pub fn schnorr_multisig_validate_and_combine_signer_pubkeys(signer_pubkey_buf: Buffer128[])-> Result<(Point, boolean), Box<dyn std::error::Error>> {
    let in_args = vec![signer_pubkey_buf];
    let out_types = vec![Point, BoolDeserializer()];
    let result = call_wasm_export(&"schnorr_multisig_validate_and_combine_signer_pubkeys", &in_args, &out_types)?;
    Ok((result[0].clone(), result[1].clone()))
}

pub fn schnorr_multisig_construct_signature_round_1()-> Result<(Buffer128, Buffer128), Box<dyn std::error::Error>> {
    let in_args = vec![];
    let out_types = vec![Buffer128, Buffer128];
    let result = call_wasm_export(&"schnorr_multisig_construct_signature_round_1", &in_args, &out_types)?;
    Ok((result[0].clone(), result[1].clone()))
}

pub fn schnorr_multisig_construct_signature_round_2(message: Buffer, private_key: Fq, signer_round_one_private_buf: Buffer128, signer_pubkeys_buf: Buffer128[], round_one_public_buf: Buffer128[])-> Result<(Fq, boolean), Box<dyn std::error::Error>> {
    let in_args = vec![message, private_key, signer_round_one_private_buf, signer_pubkeys_buf, round_one_public_buf];
    let out_types = vec![Fq, BoolDeserializer()];
    let result = call_wasm_export(&"schnorr_multisig_construct_signature_round_2", &in_args, &out_types)?;
    Ok((result[0].clone(), result[1].clone()))
}

pub fn schnorr_multisig_combine_signatures(message: Buffer, signer_pubkeys_buf: Buffer128[], round_one_buf: Buffer128[], round_two_buf: Fr[])-> Result<(Buffer32, Buffer32, boolean), Box<dyn std::error::Error>> {
    let in_args = vec![message, signer_pubkeys_buf, round_one_buf, round_two_buf];
    let out_types = vec![Buffer32, Buffer32, BoolDeserializer()];
    let result = call_wasm_export(&"schnorr_multisig_combine_signatures", &in_args, &out_types)?;
    Ok((result[0].clone(), result[1].clone(), result[2].clone()))
}

