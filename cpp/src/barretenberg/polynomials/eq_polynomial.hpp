// === AUDIT STATUS ===
// internal:    { status: not started, auditors: [], date: YYYY-MM-DD }
// external_1:  { status: not started, auditors: [], date: YYYY-MM-DD }
// external_2:  { status: not started, auditors: [], date: YYYY-MM-DD }
// =====================

#pragma once
#include "barretenberg/common/bb_bench.hpp"
#include "barretenberg/common/compiler_hints.hpp"
#include "barretenberg/common/thread.hpp"
#include "barretenberg/numeric/bitop/get_msb.hpp"
#include "barretenberg/stdlib/primitives/bool/bool.hpp"
#include "gate_separator.hpp"

#include <cstddef>
#include <vector>
namespace bb {

/**
 * @brief Prover-side eq(X, r) polynomial over Boolean hypercube.
 *
 * eq(X, r) = ∏_{i=0}^{d-1} ((1 - r_i)(1 - X_i) + r_i X_i)
 *          = ∏_{i=0}^{d-1} (b_i + a_i X_i),  where a_i = 2r_i - 1, b_i = 1 - r_i
 *
 * This class provides two construction strategies:
 *
 * 1. **Optimal method (default)**: Uses coordinate transformation + GateSeparatorPolynomial
 *    - Transforms eq(X, r) = C · ∏_i (1 + (γ_i - 1) X_i), where γ_i = r_i / (1 - r_i), C = ∏_i (1 - r_i)
 *    - Delegation to GateSeparatorPolynomial::compute_beta_products uses the optimal pow_β algorithm
 *    - **Cost**: ~2^d multiplications (ignoring lower-order terms from transformation)
 *    - **Requirement**: All challenges r_i ≠ 1 (to avoid division by zero in γ_i = r_i / (1 - r_i))
 *
 * 2. **Fallback method**: Direct incremental table construction for edge cases
 *    - Builds the 2^d coefficient table by expanding one variable at a time
 *    - **Cost**: 2^(d+1) - 2 multiplications (sum over rounds: ∑_{i=0}^{d-1} 2^(i+1) = 2^(d+1) - 2)
 *    - **Usage**: Automatically invoked when any r_i = 1 (detected by checking if ∏_i (1 - r_i) = 0)
 *    - **Performance**: ~2× slower than optimal method, but handles all edge cases correctly
 *
 * In production, challenges are typically generated by hashing the transcript, so with high probability
 * no r_i = 1, and the optimal method is used.
 */
template <typename FF> class ProverEqPolynomial {

  public:
    /**
     * @brief Construct eq(X, r) coefficient table over Boolean hypercube {0,1}^d.
     *
     * Automatically selects between optimal and fallback methods based on challenge values:
     * - If all r_i ≠ 1: uses optimal method (~2^d muls) via GateSeparatorPolynomial
     * - If any r_i = 1: uses fallback method (~2^(d+1) muls) via direct construction
     *
     * @param challenges The evaluation point r = (r_0, ..., r_{d-1})
     * @param log_num_monomials The dimension d (must equal challenges.size())
     * @return Polynomial<FF> Coefficient table of size 2^d indexed by Boolean masks
     */
    static Polynomial<FF> construct(std::span<const FF> challenges, size_t log_num_monomials)
    {
        // Compute scaling factor C = ∏_i (1 - r_i)
        FF scaling_factor = compute_scaling_factor(challenges);

        // In production, challenges are generated by hashing the transcript, hence with high probability
        // none of them equals 1. If C = 0, at least one r_i = 1, so we must use the fallback method.
        if (scaling_factor.is_zero()) {
            return construct_eq_with_edge_cases(challenges, log_num_monomials);
        }

        // Optimal path: transform to γ_i = r_i / (1 - r_i) and delegate to pow_β algorithm
        return GateSeparatorPolynomial<FF>::compute_beta_products(
            transform_challenge(challenges), log_num_monomials, scaling_factor);
    };

    /**
     * @brief Compute the scaling factor C = ∏_i (1 - r_i) for coordinate transformation.
     *
     * Used to detect edge cases: if C = 0, then at least one r_i = 1, and we must use the fallback method.
     *
     * @param challenge The evaluation point r = (r_0, ..., r_{d-1})
     * @return FF The product C = (1 - r_0) · (1 - r_1) · ... · (1 - r_{d-1})
     */
    static FF compute_scaling_factor(std::span<const FF> challenge)
    {
        FF out(1);
        const FF one(1);
        for (auto u_i : challenge) {
            out *= (one - u_i);
        }
        return out;
    }

    /**
     * @brief Transform challenges r_i to γ_i = r_i / (1 - r_i) for optimal method.
     *
     * The coordinate transformation eq(X, r) = C · ∏_i (1 + γ_i X_i) enables use of the
     * optimal pow_β algorithm. Uses batch inversion for efficiency.
     *
     * @param challenges The evaluation point r = (r_0, ..., r_{d-1})
     * @return std::vector<FF> The transformed challenges γ = (γ_0, ..., γ_{d-1})
     *
     * @note Requires all r_i ≠ 1 to avoid division by zero. Caller must check via compute_scaling_factor.
     */
    static std::vector<FF> transform_challenge(std::span<const FF> challenges)
    {
        std::vector<FF> result;
        std::vector<FF> denominators;
        for (const auto& challenge : challenges) {
            denominators.push_back((FF(1) - challenge));
        }

        FF::batch_invert(denominators);

        for (const auto& [denom_inverted, challenge] : zip_view(denominators, challenges)) {
            result.push_back(denom_inverted * challenge);
        }

        return result;
    }

    /**
     * @brief Fallback method: direct construction of eq(X, r) coefficient table for edge cases.
     *
     * Builds the 2^d coefficient table incrementally by processing one Boolean variable at a time.
     * Each iteration doubles the table size by appending coefficients for X_i = 1 to those for X_i = 0.
     *
     * **Algorithm**: For each variable i ∈ {0, ..., d-1}:
     *   - Given table T of size 2^i representing eq restricted to first i variables
     *   - Expand to size 2^(i+1) by computing:
     *     - T[mask] = T[mask >> 1] · b_i      if bit i of mask is 0
     *     - T[mask] = T[mask >> 1] · (b_i + a_i) if bit i of mask is 1
     *   where a_i = 2r_i - 1, b_i = 1 - r_i
     *
     * **Cost analysis**:
     *   - Round i processes 2^i coefficients, producing 2^(i+1) outputs
     *   - Each output requires: 1 addition + 1 multiplication (for upper half) or 1 multiplication (for lower half)
     *   - Total multiplications: ∑_{i=0}^{d-1} 2^(i+1) = 2^(d+1) - 2 ≈ 2 · 2^d
     *   - **Performance**: ~2× slower than optimal method, but works for all challenge values
     *
     * @param r The evaluation point r = (r_0, ..., r_{d-1})
     * @param log_num_monomials The dimension d (must equal r.size())
     * @return Polynomial<FF> Coefficient table of size 2^d indexed by Boolean masks
     */
    static Polynomial<FF> construct_eq_with_edge_cases(std::span<const FF> r, size_t log_num_monomials)
    {
        const size_t d = r.size();
        BB_ASSERT_EQ(d, log_num_monomials, "expect log_num_monomials == r.size()");
        const size_t N = 1UL << d;

        // Precompute per-variable linear/constant coeffs:
        // eq(X,r) = ∏_i ( b_i + a_i X_i ),  a_i = 2r_i - 1,  b_i = 1 - r_i
        std::vector<FF> eq_linear_coeffs(d);
        std::vector<FF> eq_constant_coeffs(d);
        for (size_t i = 0; i < d; ++i) {
            eq_linear_coeffs[i] = r[i] + r[i] - FF(1); // a_i
            eq_constant_coeffs[i] = FF(1) - r[i];      // b_i
        }

        // Start with table size 1: [1]
        Polynomial<FF> current(
            /*size*/ 1, /*virtual_size*/ N, /*start_index*/ 0, Polynomial<FF>::DontZeroMemory::FLAG);
        current.at(0) = FF(1);

        // Grow one variable at a time: size doubles each round
        for (size_t var_idx = 0; var_idx < d; ++var_idx) {
            const FF a_i = eq_linear_coeffs[var_idx];
            const FF b_i = eq_constant_coeffs.at(var_idx);

            const size_t prev_size = current.size();
            const size_t next_size = prev_size << 1;

            Polynomial<FF> next(/*size*/ next_size,
                                /*virtual_size*/ N,
                                /*start_index*/ 0,
                                Polynomial<FF>::DontZeroMemory::FLAG);

            // Write lower and upper halves
            const FF* src = current.data();
            FF* dst = next.data();

            for (size_t j = 0; j < prev_size; ++j) {
                const FF v = src[j];
                dst[j] = v * b_i;                     // bit_i = 0: multiply by b_i
                dst[j + prev_size] = v * (b_i + a_i); // bit_i = 1: multiply by (b_i + a_i)
            }

            current = std::move(next);
        }

        // current now holds all 2^d coefficients, index = mask over {X_i}
        return current;
    }
};

/**
 * @brief Verifier-side polynomial for division-free evaluation of eq(r, u).
 *
 * eq(r,u) = ∏_i ((1 - r_i)(1 - u_i) + r_i u_i)
 *         = ∏_i ( b_i + u_i * a_i ), where:
 *             a_i = 2 r_i - 1
 *             b_i = 1 - r_i
 *
 * Features:
 *  - O(d) evaluation with no divisions.
 *  - Incremental "combiner challenge" updates: multiply in the i-th factor and advance.
 */
template <typename FF> struct VerifierEqPolynomial {
    // --- Instance data (fixed for a proof) ---
    std::vector<FF> r; // instance challenges r_i
    std::vector<FF> a; // a_i = 2 r_i - 1
    std::vector<FF> b; // b_i = 1 - r_i

    explicit VerifierEqPolynomial(const std::vector<FF>& r_in) { initialize(r_in); }

    void initialize(const std::vector<FF>& r_in)
    {
        r = r_in;
        a.resize(r.size());
        b.resize(r.size());
        for (size_t i = 0; i < r.size(); ++i) {
            a[i] = r[i] + r[i] - FF(1); // 2 r_i - 1
            b[i] = FF(1) - r[i];        // 1 - r_i
        }
    }

    // ---- Evaluate eq(X, r) at u ----
    FF evaluate(std::span<const FF> u) const
    {
        assert(u.size() == r.size());
        FF acc = FF(1);
        for (size_t i = 0; i < u.size(); ++i) {
            // term_i = b_i + u_i * a_i
            acc *= (b[i] + u[i] * a[i]);
        }
        return acc;
    }

    // ---- Compute eq(r, u) without constructing the object ----
    static FF eval(std::span<const FF> r_in, std::span<const FF> u)
    {
        assert(r_in.size() == u.size());
        FF acc = FF(1);
        for (size_t i = 0; i < r_in.size(); ++i) {
            const FF ai = r_in[i] + r_in[i] - FF(1);
            const FF bi = FF(1) - r_in[i];
            acc *= (bi + u[i] * ai);
        }
        return acc;
    }
};

} // namespace bb
