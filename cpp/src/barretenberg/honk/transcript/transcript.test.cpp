#include "transcript.hpp"
#include "barretenberg/ecc/curves/bn254/g1.hpp"
#include "barretenberg/honk/composer/standard_honk_composer.hpp"
#include "barretenberg/honk/sumcheck/polynomials/univariate.hpp"
#include "barretenberg/numeric/bitop/get_msb.hpp"
#include "barretenberg/proof_system/flavor/flavor.hpp"
// #include "standard_honk_composer.hpp"
#include <cstddef>
#include <cstdint>
#include <gtest/gtest.h>
#include <string>

using namespace honk;

template <typename FF> class TranscriptTest : public testing::Test {
  public:
    /**
     * @brief Construct a manifest for a standard Honk proof with n = 8, (d = 3)
     *
     * @return std::map<size_t, RoundData>
     */
    std::map<size_t, RoundData> construct_standard_honk_manifest(size_t circuit_size)
    {
        std::map<size_t, RoundData> manifest_expected;

        size_t log_n(numeric::get_msb(circuit_size));

        size_t max_relation_length = 5;
        size_t size_FF = sizeof(FF);
        size_t size_G = 2 * size_FF;
        size_t size_uni = max_relation_length * size_FF;
        size_t size_evals = StandardArithmetization::NUM_POLYNOMIALS * size_FF;

        // clang-format off

        size_t round = 0;
        manifest_expected[round].entries = {                {"circuit_size", 4},
                                                            {"public_input_size", 4},
                                                            {"public_input_0", size_FF},
                                                            {"W_1", size_G},
                                                            {"W_2", size_G},
                                                            {"W_3", size_G} };
        manifest_expected[round].challenge_label =          {"beta", "gamma"};

        round++;
        manifest_expected[round].entries = {                {"Z_PERM", size_G} };
        manifest_expected[round].challenge_label =          {"Sumcheck:alpha", "Sumcheck:zeta"};
        
        for (size_t i = 0; i < log_n; ++i) {
            round++;
            std::string idx = std::to_string(i);
            manifest_expected[round].entries = {            {"Sumcheck:univariate_" + idx, size_uni} };
            manifest_expected[round].challenge_label =      {"Sumcheck:u_" + idx};
        }

        round++;
        manifest_expected[round].entries = {                {"multivariate_evaluations", size_evals} };
        manifest_expected[round].challenge_label =          {"rho"};

        round++;
        for (size_t i = 1; i < log_n; ++i) {
            std::string idx = std::to_string(i);
            manifest_expected[round].entries.emplace_back   ("Gemini:FOLD_" + idx, size_G ); 
        }
        manifest_expected[round].challenge_label =          {"Gemini:r"};

        round++;
        for (size_t i = 0; i < log_n; ++i) {
            std::string idx = std::to_string(i);
            manifest_expected[round].entries.emplace_back   ("Gemini:a_" + idx, size_FF ); 
        }
        manifest_expected[round].challenge_label =          {"Shplonk:nu"};

        round++;
        manifest_expected[round].entries = {                {"Shplonk:Q", size_G} };
        manifest_expected[round].challenge_label =          {"Shplonk:z"};
        
        round++;
        manifest_expected[round].entries = {                {"KZG:W", size_G} };
        manifest_expected[round].challenge_label =          {}; // no challenge

        // clang-format on

        return manifest_expected;
    }
};

using FieldTypes = testing::Types<barretenberg::fr>;
TYPED_TEST_SUITE(TranscriptTest, FieldTypes);

/**
 * @brief Ensure consistency between the manifests generated by the standard honk prover and verfier for a simple
 * circuit of size n = 8
 *
 */
TYPED_TEST(TranscriptTest, StandardHonkManifest)
{
    auto composer = StandardHonkComposer();
    fr a = 1;
    composer.circuit_constructor.add_variable(a);
    composer.circuit_constructor.add_public_variable(a);

    auto prover = composer.create_prover();
    plonk::proof proof = prover.construct_proof();
    auto verifier = composer.create_verifier();
    bool verified = verifier.verify_proof(proof);
    ASSERT_TRUE(verified);

    auto manifest_expected = TestFixture::construct_standard_honk_manifest(prover.key->circuit_size);

    // Uncomment to see a summary printout of the transcript
    // prover.transcript.print();

    ASSERT_EQ(prover.transcript.get_manifest(), manifest_expected);
}

/**
 * @brief Test and demonstrate the basic functionality of the prover and verifier transcript
 *
 */
TYPED_TEST(TranscriptTest, ProverAndVerifierBasic)
{
    constexpr size_t LENGTH = 8;

    using Fr = barretenberg::fr;
    using Univariate = honk::sumcheck::Univariate<Fr, LENGTH>;
    using Commitment = barretenberg::g1::affine_element;

    std::array<Fr, LENGTH> evaluations;
    for (auto& eval : evaluations) {
        eval = Fr::random_element();
    }

    // Add some junk to the transcript and compute challenges
    uint32_t data = 25;
    auto scalar = Fr::random_element();
    auto commitment = Commitment::one();
    auto univariate = Univariate(evaluations);

    // Instantiate a prover transcript and mock an example protocol
    ProverTranscript<Fr> prover_transcript;

    // round 0
    prover_transcript.send_to_verifier("data", data);
    Fr alpha = prover_transcript.get_challenge("alpha");

    // round 1
    prover_transcript.send_to_verifier("scalar", scalar);
    prover_transcript.send_to_verifier("commitment", commitment);
    Fr beta = prover_transcript.get_challenge("beta");

    // round 2
    prover_transcript.send_to_verifier("univariate", univariate);
    auto [gamma, delta] = prover_transcript.get_challenges("gamma", "delta");

    // Instantiate a verifier transcript from the raw bytes of the prover transcript; receive data and generate
    // challenges according to the example protocol
    VerifierTranscript<Fr> verifier_transcript(prover_transcript.proof_data);

    // round 0
    auto data_received = verifier_transcript.template receive_from_prover<uint32_t>("data");
    Fr verifier_alpha = verifier_transcript.get_challenge("alpha");

    // round 1
    auto scalar_received = verifier_transcript.template receive_from_prover<Fr>("scalar");
    auto commitment_received = verifier_transcript.template receive_from_prover<Commitment>("commitment");
    Fr verifier_beta = verifier_transcript.get_challenge("beta");

    // round 2
    auto univariate_received = verifier_transcript.template receive_from_prover<Univariate>("univariate");
    auto [verifier_gamma, verifier_delta] = verifier_transcript.get_challenges("gamma", "delta");

    // Check the correctness of the elements received by the verifier
    EXPECT_EQ(data_received, data);
    EXPECT_EQ(scalar_received, scalar);
    EXPECT_EQ(commitment_received, commitment);
    EXPECT_EQ(univariate_received, univariate);

    // Check consistency of prover and verifier challenges
    EXPECT_EQ(alpha, verifier_alpha);
    EXPECT_EQ(beta, verifier_beta);
    EXPECT_EQ(gamma, verifier_gamma);
    EXPECT_EQ(delta, verifier_delta);

    // Check consistency of the generated manifests
    EXPECT_EQ(prover_transcript.get_manifest(), verifier_transcript.get_manifest());
}

/**
 * @brief Demonstrate that the verifier is not explicitly restricted from deviating from the 'manifest'
 *
 */
TYPED_TEST(TranscriptTest, VerifierMistake)
{
    using Fr = barretenberg::fr;

    auto scalar_1 = Fr::random_element();
    auto scalar_2 = Fr::random_element();

    ProverTranscript<Fr> prover_transcript;

    prover_transcript.send_to_verifier("scalar1", scalar_1);
    prover_transcript.send_to_verifier("scalar2", scalar_2);
    auto prover_alpha = prover_transcript.get_challenge("alpha");

    VerifierTranscript<Fr> verifier_transcript(prover_transcript.proof_data);

    verifier_transcript.template receive_from_prover<Fr>("scalar1");
    // accidentally skip receipt of "scalar2"...
    // but then generate a challenge anyway
    auto verifier_alpha = verifier_transcript.get_challenge("alpha");

    // Challenges will not agree and neither will the manifests
    EXPECT_NE(prover_alpha, verifier_alpha);
    EXPECT_NE(prover_transcript.get_manifest(), verifier_transcript.get_manifest());
}