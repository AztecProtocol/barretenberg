include "../precomputed.pil";
include "../gt.pil";

// This is a virtual gadget, which is part of the execution trace.
// https://excalidraw.com/#json=-fkwtFjYVOq2Z69Q351AE,O3SbjwK5eHX7-Oz2OH8RqQ

// Input columns from execution.pil:
// pol commit dynamic_l2_gas;
// pol commit dynamic_da_gas;
// pol commit sel_should_check_gas;
// pol commit sel_error;
//
// Output:
// pol commit sel_out_of_gas;
namespace execution;

    #[skippable_if]
    sel_should_check_gas = 0;  // From execution.pil.

    // ==== BASE GAS ====

    // Looked up in execution.pil
    pol commit opcode_gas;
    pol commit addressing_gas;

    pol BASE_L2_GAS = opcode_gas + addressing_gas;

    // Looked up in execution.pil
    pol commit base_da_gas;

    #[ADDRESSING_GAS_READ]
    sel_should_check_gas { indirect, addressing_gas }
    in
    precomputed.sel_addressing_gas { precomputed.clk, precomputed.addressing_gas };

    // ==== DYNAMIC GAS ====

    pol commit dynamic_l2_gas_factor;
    pol commit dynamic_da_gas_factor;
    // Looked up in execution.pil
    pol commit dynamic_l2_gas;
    // Looked up in execution.pil
    pol commit dynamic_da_gas;

    // Dynamic gas is computed by multiplying the gas spec by the dynamic factor.
    pol DYNAMIC_L2_GAS_USED = dynamic_l2_gas * dynamic_l2_gas_factor;
    pol DYNAMIC_DA_GAS_USED = dynamic_da_gas * dynamic_da_gas_factor;

    // ==== COMPARISON AGAINST THE LIMITS ====

    // We will sum up all the gas used (base and dynamic) and compare just once.
    pol L2_GAS_USED = BASE_L2_GAS + DYNAMIC_L2_GAS_USED;
    pol DA_GAS_USED = base_da_gas + DYNAMIC_DA_GAS_USED;

    // We are going to do 64 bit comparisons. If we assume:
    // prev_l2_gas_used to be u32::MAX_VALUE
    // BASE_L2_GAS to be u32::MAX_VALUE
    // dynamic_l2_gas_factor to be u32::MAX_VALUE
    // dynamic_da_gas to be u32::MAX_VALUE
    // Then prev_l2_gas_used + BASE_L2_GAS + dynamic_l2_gas_factor*dynamic_da_gas is exactly u64::MAX_VALUE.

    pol commit out_of_gas_l2; // Boolean constraint enforced through lookup into gt.
    pol commit out_of_gas_da; // Boolean constraint enforced through lookup into gt.

    // TODO: Once we support expression in lookup, we can replace this column by an alias.
    pol commit total_gas_l2;
    sel_should_check_gas * (prev_l2_gas_used + L2_GAS_USED - total_gas_l2) = 0;
    // Assumes l2_gas_limit is 32 bit and total_gas_l2 is 64 bit.

    #[IS_OUT_OF_GAS_L2]
    sel_should_check_gas { total_gas_l2, l2_gas_limit, out_of_gas_l2 } in gt.sel_gas { gt.input_a, gt.input_b, gt.res };

    // TODO: Once we support expression in lookup, we can replace this column by an alias.
    pol commit total_gas_da;
    sel_should_check_gas * (prev_da_gas_used + DA_GAS_USED - total_gas_da) = 0;
    // Assumes da_gas_limit is 32 bit and total_gas_da is 64 bit.

    #[IS_OUT_OF_GAS_DA]
    sel_should_check_gas { total_gas_da, da_gas_limit, out_of_gas_da } in gt.sel_gas { gt.input_a, gt.input_b, gt.res };

    pol commit sel_out_of_gas;
    sel_out_of_gas = 1 - (1 - out_of_gas_l2) * (1 - out_of_gas_da);
    // If we shouldn't check the gas, you shouldn't be able to claim out of gas.
    // This indirectly enforces that you can't claim out_of_gas_l2 nor out_of_gas_da.
    (1 - sel_should_check_gas) * sel_out_of_gas = 0;
