include "memory.pil";
include "constants_gen.pil";

/**
 * Two usages exist for this gadget (read and write). Explanations below.
 *
 * Usage for reading a slice (permutation and not lookup):
 * sel { state_in_00, state_in_10, ... state_in_44, // Order by x coordinate first, then y.
 *       clk, src_addr, space_id, tag_error }
 * is
 * keccak_memory.start_read { keccak_memory.val_0_, keccak_memory.val_1_, ... keccak_memory.val_24_,
 *                            keccak_memory.clk, keccak_memory.addr, keccak_memory.space_id, keccak_memory.tag_error };
 *
 * Inputs: state_in_00, state_in_01, ... state_in_44, clk, src_addr, space_id
 * Output: tag_error
 *
 * Usage for writing a slice (permutation and not lookup):
 * sel_slice_write { state_out_00, state_out_10, ... state_out_44, // Order by x coordinate first, then y.
 *                   clk, dst_addr, space_id, round }
 * is
 * keccak_memory.start_write { keccak_memory.val_0_, keccak_memory.val_1_, ... keccak_memory.val_24_,
 *                             keccak_memory.clk, keccak_memory.addr, keccak_memory.space_id, 24 };
 *
 * Inputs: state_out_00, state_out_10, ... state_out_44, clk, dst_addr, space_id, round
 * No output. Write can never fail. The state_out values are assumed fit in U64.
 * Parameter: round is fixed to 24.
 *
 * - state_in_00, state_in_10, ... state_in_44 are the 25 U64 keccak state values of the read slice.
 * - state_out_00, state_out_10 ... state_out_44 are the 25 U64 keccak state values of the write slice.
 * - dst_addr and src_addr are the first memory offset of the pertaining slice.
 * - space_id serves to propagate the right memory space up to the memory trace.
 * - clk is required for the unicity in the permutation and to propagate to the memory trace
 *   to unambiguously order the memory operations.
 * - tag_error is set to 1 if any tag error is detected.
 * - Passing the tuple element `round` serves to constrain it to be equal to 24 (see keccakf1600.pil).
 */

namespace keccak_memory;

// This gadget is only dedicated to read and write memory slices corresponding
// to the input and output of keccakf1600. An input and output state for keccakf1600
// is composed of 25 U64 contiguous memory values. This gadget will read or write
// 25 such values based on a passed memory offset. It read/writes the 25 values
// and for the read case checks that each tag is U64. Otherwise, we return a tag error.
//
// Precondition: We assume the passed offset being such that offset + 24 < 2^32, so
//               that the slice fits into the memory space.

// We use a multi-row computation to shift the read/written values to the row where the lookup
// applies. Values are indexed according to 1 index val_k_ where 0 <= k <= 24. The multi-row
// computation is performed by toggling the `start_read` or `start_write` columns. We need two
// different `start` selectors because the read and write operations are using different source
// tuples in keccakf1600.pil.

//#################################################################################################
//                  High-Level Trace Structure Columns
//#################################################################################################
//   ctr   ctr_end  sel   start_read  last   rw  addr  tag   val_0_  val_1_  val_2_  ....  val_24_  single_tag_error  tag_error
//    1       0      1      1          0      0   38    U64    43     267     17           238          0                 0
//    2       0      1      0          0      0   39    U64   267      17            238                0                 0
//    3       0      1      0          0      0   40    U64    17                                       0                 0
//    ...    ...    ...    ...        ...     0   ..    U64    **      ***                              0                 0
//    25      1      1      0          1      0   62    U64   238       0      0     ...    0           0                 0

// A read/write memory operation is performed at each row at memory offset `addr`, `rw` boolean indicates
// whether we write or read. The column val_0_ stores the read/write value and tag the tag value.
// Note that in this case, val_0_ might not be in range of U64 values, this is not an issue because
// whenever a tag error applies, the main keccak permutation is disabled (conditioned by sel_no_error
// in keccakf1600.pil).
// Each column value val_k_ is shifted to the right going bottom-up and finally is laid out
// horizontally in the first row.
// For a read operation, single_tag_error is toggled whenever tag is not U64.
// When this happens, we toggle `last` and stop the multi-rows computation prematurely.
// Therefore, when a tag error occurs the trace looks like:

//   ctr  ctr_end   sel   start_read last   rw  addr  tag   val_0_  val_1_  val_2_  ....  val_24_  single_tag_error  tag_error
//    1       0      1      1         0      0   38    U64    43      267      17            0         0                 1
//    2       0      1      0         0      0   39    U64   267       17                              0                 1
//    3       0      1      0         1      0   40    FF     17        0      0    ....     0         1                 1

// The selector `last` is defined to be `ctr_end` OR `single_tag_error`.
// To propagate the single_tag_error value, we use the column `tag_error`.
// Note that we need a separate column because `single_tag_error` defines `last` which
// controls when the computation or propagation stops.

pol commit sel;
sel * (1 - sel) = 0;

// No relations will be checked if this identity is satisfied.
#[skippable_if]
sel = 0;

pol commit start_read;
start_read * (1 - start_read) = 0;

pol commit start_write;
start_write * (1 - start_write) = 0;

pol commit clk;
pol commit ctr;
pol commit addr;
pol commit tag;
pol commit space_id;
pol commit tag_error;
pol commit single_tag_error;

// Values for memory slice
pol commit val[25];

// We enforce the initial ctr to be set to 1.
#[CTR_INIT]
(start_read + start_write) * (ctr - 1) = 0;

#[RW_READ_INIT]
start_read * rw = 0;
#[RW_WRITE_INIT]
start_write * (1 - rw) = 0;

// sel == 1 <==> ctr != 0
pol commit ctr_inv;
#[SEL_CTR_NON_ZERO]
ctr * ((1 - sel) * (1 - ctr_inv) + ctr_inv) - sel = 0;

// ctr_end is toggled when all slice rows have been processed.
pol commit ctr_end;
ctr_end * (1 - ctr_end) = 0;

// We define ctr_end == 1 <==> ctr == AVM_KECCAKF1600_STATE_SIZE (25)
pol commit state_size_min_ctr_inv;
#[CTR_END]
sel * ((constants.AVM_KECCAKF1600_STATE_SIZE - ctr) * (ctr_end * (1 - state_size_min_ctr_inv) + state_size_min_ctr_inv) + ctr_end - 1) = 0;

// Last ctr of a multi-rows processing of a slice
pol commit last;

// last == ctr_end || single_tag_error
// `last` is boolean by definition
#[LAST]
last = 1 - (1 - ctr_end) * (1 - single_tag_error);

#[CTR_INCREMENT]
// Note: sel factor is required for an empty row to satisfy this relation
sel * (1 - last) * (ctr' - ctr - 1) = 0;

// Copied from memory.pil through lookup and constrained to be boolean in memory.pil.
pol commit rw;

single_tag_error * (1 - single_tag_error) = 0;

#[NO_TAG_ERROR_ON_WRITE]
rw * single_tag_error = 0;

#[TAG_ERROR_INIT]
last * (tag_error - single_tag_error) = 0;

#[TAG_ERROR_PROPAGATION]
(1 - last) * (tag_error - tag_error') = 0;

// No need to enforce a boolean constraint for tag_error as it follows from the above constraints.

#[MEM_ADDR_INCREMENT]
sel * (1 - last) * (addr + 1 - addr') = 0;

#[SPACEID_PROPAGATION]
(1 - last) * (space_id - space_id') = 0;

#[CLK_PROPAGATION]
(1 - last) * (clk' - clk) = 0;

#[RW_PROPAGATION]
(1 - last) * (rw' - rw) = 0;

// Check if the tag is U64
// We constrain single_tag_error == 1 <==> tag is not U64.
pol commit tag_min_u64_inv;
pol TAG_MIN_U64 = tag - constants.MEM_TAG_U64;
#[SINGLE_TAG_ERROR]
sel * (TAG_MIN_U64 * ((1 - single_tag_error) * (1 - tag_min_u64_inv) + tag_min_u64_inv) - single_tag_error) = 0;

#[SINGLE_TAG_ERROR_BOOLEAN]
single_tag_error * (1 - single_tag_error) = 0;

#[VAL01]
val[1] = (1 - last) * val[0]';
#[VAL02]
val[2] = (1 - last) * val[1]';
#[VAL03]
val[3] = (1 - last) * val[2]';
#[VAL04]
val[4] = (1 - last) * val[3]';
#[VAL05]
val[5] = (1 - last) * val[4]';
#[VAL06]
val[6] = (1 - last) * val[5]';
#[VAL07]
val[7] = (1 - last) * val[6]';
#[VAL8]
val[8] = (1 - last) * val[7]';
#[VAL09]
val[9] = (1 - last) * val[8]';
#[VAL10]
val[10] = (1 - last) * val[9]';
#[VAL11]
val[11] = (1 - last) * val[10]';
#[VAL12]
val[12] = (1 - last) * val[11]';
#[VAL13]
val[13] = (1 - last) * val[12]';
#[VAL14]
val[14] = (1 - last) * val[13]';
#[VAL15]
val[15] = (1 - last) * val[14]';
#[VAL41]
val[16] = (1 - last) * val[15]';
#[VAL17]
val[17] = (1 - last) * val[16]';
#[VAL18]
val[18] = (1 - last) * val[17]';
#[VAL19]
val[19] = (1 - last) * val[18]';
#[VAL20]
val[20] = (1 - last) * val[19]';
#[VAL21]
val[21] = (1 - last) * val[20]';
#[VAL22]
val[22] = (1 - last) * val[21]';
#[VAL23]
val[23] = (1 - last) * val[22]';
#[VAL24]
val[24] = (1 - last) * val[23]';

#[SLICE_TO_MEM]
sel { clk, space_id, addr, val[0], tag, rw }
is memory.sel_keccak { memory.clk, memory.space_id, memory.address, memory.value, memory.tag, memory.rw };

// Used to constrain the number of rounds in keccakf1600.pil through the slice_write lookup.
pol commit num_rounds;
sel * (num_rounds - constants.AVM_KECCAKF1600_NUM_ROUNDS) = 0; // TODO: Remove once we support constants in lookups
