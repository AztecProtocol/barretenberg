include "precomputed.pil";
include "calldata_hashing.pil";

// ###########
// Calldata
// ###########
//
// This circuit fills the calldata column with one field per row. We constrain that the index
// increments by one each row until we begin a new calldata instance, where the context_id must
// increase and latch must indicate the final row.
//
// The values in the calldata columns are really hints. Their correctness is constrained by calldata_hashing.pil,
// where the size and hash of the calldata is validated. The hash is looked up in the tx and matched to
// the one in a tx's public inputs, and the size is looked up for each call. These values should be
// looked up via calldata_hashing.pil's latch against the context_id.
//
// For empty calldata, we have a special case where no value exists, but should have a row in this
// trace to indicate that a certain context_id has been processed:
//  index |  value | context_id | latch |
// -------+--------+------------+-------+
//    0   |    0   |     id     |   1   |
// This is the only case in which index = 0 and sel = 1. Note that no lookups should access this trace
// with index = 0 unless to confirm that the calldata is empty (data_copy and calldata_hashing lookup
// all existing values with a +1).
//
// e.g. calldata: [0x111, 0x222, 0x333, 0x444]
// calldata.pil:
//  index |  value | context_id | latch |
// -------+--------+------------+-------+
//    1   |  0x111 |     1      |   0   |
//    2   |  0x222 |     1      |   0   |
//    3   |  0x333 |     1      |   0   |
//    4   |  0x444 |     1      |   1   |
//
// e.g. cd_hash_0 = H([sep, 0x111, 0x222, 0x333, 0x444])
// calldata_hashing.pil:
//   index_0_ |  index_1_ | index_2_ | context_id | input_0_ | input_1_ | input_2_ | output_hash | latch | start | rounds_rem | padding | calldata_size |
// -----------+-----------+----------+------------+----------+----------+----------+-------------+-------+-------+------------+---------+---------------+
//     0      |     1     |     2    |      1     |    sep   |   0x111  |   0x222  |  cd_hash_0  |   0   |   1   |     2      |    0    |       4       |
//     3      |     4     |     5    |      1     |   0x333  |   0x444  |     0    |  cd_hash_0  |   1   |   0   |     1      |    1    |       4       |

namespace calldata;

    #[skippable_if]
    sel = 0;

    pol commit sel;
    pol commit value;
    pol commit context_id;
    // **NOTE** The index starts at one in this trace (see above comment for special case of empty calldata and index = 0):
    // We do not currently constrain this (or the existence of a 'start' column) since calldata_hashing constrains it
    // and all looked up calldata values are basically hints which must also go through calldata_hashing.
    //      e.g. data_copy will look up values in this trace by context_id. We know that these values are valid (and
    //      start at index=1) because data_copy also looks up the calldata size by the same context_id, constrained by
    //      calldata_hashing, which itself constrains the index.
    // We could constrain this here by introducing a start column:
    //      pol commit start;
    // Adding relations like (see calldata_hashing.pil's):
    //      #[START_AFTER_LATCH]
    //      sel' * (start' - FIRST_OR_LAST_CALLDATA) = 0;
    //      #[START_INDEX_IS_ONE]
    //      sel * start * (is_not_empty * (index - 1) + is_empty * index) = 0;
    // If start = 1, #[START_INDEX_IS_ONE] should constrain that index = 1 unless we have empty calldata. In that case
    // the 'special' row must have latch = 1, index = 0, value = 0, and will be constrained by calldata_hashing to have
    // size = 0. This is a different case to a calldata of one field of value 0, where index = 1.
    pol commit index;
    // Designates end of calldata for that context_id
    pol commit latch;
    latch * (1 - latch) = 0;

    // latch == 1 ==> sel == 1
    #[SEL_TOGGLED_AT_LATCH]
    latch * (1 - sel) = 0;

    pol FIRST_OR_LAST_CALLDATA = precomputed.first_row + latch;
    // Index increments until latch
    sel * (1 - FIRST_OR_LAST_CALLDATA) * (index' - index - 1) = 0;


    // If sel = 0, sel' != 1
    #[TRACE_CONTINUITY]
    (1 - precomputed.first_row) * (1 - sel) * sel' = 0;

    // Context id does not change until we latch
    #[CONTEXT_ID_CONTINUITY]
    (1 - FIRST_OR_LAST_CALLDATA) * (context_id - context_id') = 0;

    // We ensure that context_id is always different and increasing at each latch:
    pol commit diff_context_id;
    diff_context_id = latch * sel' * (context_id' - context_id - 1);

    #[RANGE_CHECK_CONTEXT_ID_DIFF]
    latch { diff_context_id } in precomputed.sel_range_16 { precomputed.clk };

