include "constants_gen.pil";
include "ff_gt.pil";
include "gt.pil";
include "precomputed.pil";
include "range_check.pil";

/**
 * PRECONDITIONS: a, b, c are in the range [0, 2^(max_bits) - 1] for non-FF values.
 * They are enforced through the range check on every MemoryValue during memory write.
 * See #[RANGE_CHECK_WRITE_TAGGED_VALUE] in memory.pil for more details.
 * When there is no error, the output c (resp. b for NOT) is written to memory and
 * is therefore guaranteed to be in the range [0, 2^(max_bits) - 1].
 * If an error occurs, the output value and tags are set to 0 (FF(0))
 * to satisfy the permutation between execution and alu, but the output
 * is not written to memory.
 *
 * USAGE: There are only specific usages of this gadget from the execution trace consisting in
 *        3 different dispatching lookups defined in execution.pil:
 *        1. #[DISPATCH_TO_ALU]: Defaults ones for every opcode except for SET and CAST which are dispatched to an ALU truncate operation.
 *        2. #[DISPATCH_TO_SET]: Dispatches SET opcode to the ALU truncate operation.
 *        3. #[DISPATCH_TO_CAST]: Dispatches CAST opcode to the ALU truncate operation.
 *
 *        1. #[DISPATCH_TO_ALU]:
 *        sel_exec_dispatch_alu {
 *           register[0], mem_tag_reg[0], register[1],
 *           mem_tag_reg[1], register[2], mem_tag_reg[2], subtrace_operation_id, sel_opcode_error
 *        } in alu.sel {
 *           alu.ia, alu.ia_tag, alu.ib, alu.ib_tag, alu.ic, alu.ic_tag, alu.op_id, alu.sel_err
 *        };
 *
 *        Except for NOT opcode, both inputs a and b come from registers 0 and 1 respectively.
 *        Auxiliary input is the operation id op_id which specifies the operation to perform.
 *        The output is c and is written to register 2. Additionally, the errot flag sel_err is
 *        passed through as sel_opcode_error.
 *        For NOT, a is the input and b the output. Register 2 is ignored.
 *
 *        2. #[DISPATCH_TO_SET]:
 *        sel_exec_dispatch_set {
 *          rop[2], rop[1], register[0], mem_tag_reg[0], sel_exec_dispatch_set, sel_opcode_error
 *        } in alu.sel_op_truncate {
 *           alu.ia, alu.ia_tag, alu.ic, alu.ia_tag, alu.sel, // alu.sel_err = 0 // precomputed.zero
 *        };
 *
 *        3. #[DISPATCH_TO_CAST]:
 *        sel_exec_dispatch_cast {
 *          register[0], rop[2], register[1], mem_tag_reg[1], sel_exec_dispatch_cast, sel_opcode_error
 *        } in alu.sel_op_truncate {
 *           alu.ia, alu.ia_tag, alu.ic, alu.ia_tag, alu.sel, // alu.sel_err = 0 // precomputed.zero
 *        };
 *
 *        For SET and CAST, the input is a and the output is c. The output is written to register 0.
 *        Additionally, the error flag sel_err is passed through as sel_opcode_error.
 *        See execution.pil for more details and explanations on use of rop[XX], register[XX], mem_tag_reg[XX], etc.
 *
 * TRACE SHAPE: 1 single row per computation for each operation and independently of error occurrence.
 *
 * ERROR HANDLING: See below.
 *
 * INERACTIONS: This trace interacts with:
 * - precomputed.pil: To retrieve tag related paramters (max_bits, max_value, etc) and power of two constants.
 * - range_check.pil: For various range checks in particular decomposition into limbs.
 * - ff_gt.pil: Used for LT/LTE operations when inputs are of type FF.
 * - gt.pil: Used for LT/LTE operations when inputs are of integral types. Also used for DIV operation (remainder smaller than divisor).
 *
*/
namespace alu;

pol commit sel; // @boolean
sel * (1 - sel) = 0;

#[skippable_if]
sel = 0;

/******************************************************************************
* Operation selectors and dispatching the operation.
******************************************************************************/

// Operation id
pol commit op_id;

// Selectors for each operation.
pol commit sel_op_add; // @boolean
pol commit sel_op_sub; // @boolean
pol commit sel_op_mul; // @boolean
pol commit sel_op_div; // @boolean
pol commit sel_op_fdiv; // @boolean
pol commit sel_op_eq; // @boolean
pol commit sel_op_lt; // @boolean
pol commit sel_op_lte; // @boolean
pol commit sel_op_not; // @boolean
pol commit sel_op_shl; // @boolean
pol commit sel_op_shr; // @boolean
pol commit sel_op_truncate; // @boolean

// Selectors are booleans
sel_op_add * (1 - sel_op_add) = 0;
sel_op_sub * (1 - sel_op_sub) = 0;
sel_op_mul * (1 - sel_op_mul) = 0;
sel_op_div * (1 - sel_op_div) = 0;
sel_op_fdiv * (1 - sel_op_fdiv) = 0;
sel_op_eq * (1 - sel_op_eq) = 0;
sel_op_lt * (1 - sel_op_lt) = 0;
sel_op_lte * (1 - sel_op_lte) = 0;
sel_op_not * (1 - sel_op_not) = 0;
sel_op_shl * (1 - sel_op_shl) = 0;
sel_op_shr * (1 - sel_op_shr) = 0;
sel_op_truncate * (1 - sel_op_truncate) = 0;


// Based on the op_id, we dispatch to the corresponding operation selector.
// Note that the op_ids below represent a binary decomposition (see constants_gen.pil). This guarantees
// that only one of the sel_op_* selectors is 1 at a time. (each constants.AVM_XX is a power of 2)
// Even though truncation is dispatched directly with destination selector sel_op_truncate, we keep
// it in this relation for the mutual exclusion of the selectors.
#[DISPATCH_OPERATION]
op_id = sel_op_add * constants.AVM_EXEC_OP_ID_ALU_ADD
      + sel_op_sub * constants.AVM_EXEC_OP_ID_ALU_SUB
      + sel_op_mul * constants.AVM_EXEC_OP_ID_ALU_MUL
      + sel_op_div * constants.AVM_EXEC_OP_ID_ALU_DIV
      + sel_op_fdiv * constants.AVM_EXEC_OP_ID_ALU_FDIV
      + sel_op_eq * constants.AVM_EXEC_OP_ID_ALU_EQ
      + sel_op_lt * constants.AVM_EXEC_OP_ID_ALU_LT
      + sel_op_lte * constants.AVM_EXEC_OP_ID_ALU_LTE
      + sel_op_not * constants.AVM_EXEC_OP_ID_ALU_NOT
      + sel_op_shl * constants.AVM_EXEC_OP_ID_ALU_SHL
      + sel_op_shr * constants.AVM_EXEC_OP_ID_ALU_SHR
      + sel_op_truncate * constants.AVM_EXEC_OP_ID_ALU_TRUNCATE;

/******************************************************************************
* Inputs and outputs and common helper selectors.
******************************************************************************/
// Inputs and outputs. Output is in ic except for NOT, where it is in ib.
pol commit ia;
pol commit ib;
pol commit ic;

// Input and output tags. Range values [0, MemoryTag::MAX].
pol commit ia_tag;
pol commit ib_tag;
pol commit ic_tag;

// Common helper selectors
pol commit sel_is_ff; // @boolean (whether input a is a field)
pol commit sel_is_u128; // @boolean (whether input a is a u128)
pol IS_NOT_FF = 1 - sel_is_ff; // @boolean Follows from definition.
pol IS_NOT_U128 = 1 - sel_is_u128; // @boolean Follows from definition.
pol SHIFT_OPS = sel_op_shl + sel_op_shr; // @boolean Follows from definition and mutual exclusion.
pol DIV_OPS = sel_op_div + sel_op_fdiv; // @boolean Follows from definition and mutual exclusion.

// Note that #[OP_ID_CHECK] ensures selectors are mutually exclusive.
// Therefore, SHIFT_OPS and DIV_OPS are boolean.

// Boolean conditions
sel_is_ff * (1 - sel_is_ff) = 0;
sel_is_u128 * (1 - sel_is_u128) = 0;

// IS_FF CHECKING

// We prove that sel_is_ff == 1 <==> ia_tag == MEM_TAG_FF
pol TAG_FF_DIFF = ia_tag - constants.MEM_TAG_FF;
pol commit tag_ff_diff_inv;
#[TAG_IS_FF]
sel * (TAG_FF_DIFF * (sel_is_ff * (1 - tag_ff_diff_inv) + tag_ff_diff_inv) + sel_is_ff - 1) = 0;

// IS_U128 CHECKING

// We prove that sel_is_u128 == 1 <==> ia_tag == MEM_TAG_U128
pol TAG_U128_DIFF = ia_tag - constants.MEM_TAG_U128;
pol commit tag_u128_diff_inv;
#[TAG_IS_U128]
sel * (TAG_U128_DIFF * (sel_is_u128 * (1 - tag_u128_diff_inv) + tag_u128_diff_inv) + sel_is_u128 - 1) = 0;

/******************************************************************************
* Error Handling
******************************************************************************/
pol commit sel_err; // @boolean Follows from definition (see #[ERR_CHECK]).
pol commit sel_tag_err; // @boolean Follows from definition (see #[TAG_ERR_CHECK]).
pol commit sel_ab_tag_mismatch; // @boolean
pol commit sel_div_0_err; // @boolean

/**
* sel_err is the main consolidated error selector.
* sel_err = sel_tag_err || sel_div_0_err
* sel_tag_err is the consolidated tag error selector.
* sel_tag_err = sel_ab_tag_mismatch || FF_TAG_ERR
* Three base error cases:
* 1) FF_TAG_ERR: Input tagged as a field for NOT, DIV, SHL, SHR or non-field for FDIV operation
* 2) sel_ab_tag_mismatch: Mismatched tags for inputs a and b for all opcodes apart from TRUNCATE.
* 3) sel_div_0_err: occurs when DIV or FDIV is performed and b == 0.
*/

// Boolean conditions
sel_ab_tag_mismatch * (1 - sel_ab_tag_mismatch) = 0;
sel_div_0_err * (1 - sel_div_0_err) = 0;

// sel_tag_err and sel_div_0_err can happen simultaneously for DIV and FDIV, so we need to OR them together.
#[ERR_CHECK]
sel_err = sel_tag_err + sel_div_0_err - sel_tag_err * sel_div_0_err;

// sel_ab_tag_mismatch and FF_TAG_ERR can happen simultaneously for DIV, SHL, SHR, so we need to OR them together.
#[TAG_ERR_CHECK]
sel_tag_err = sel_ab_tag_mismatch + FF_TAG_ERR - sel_ab_tag_mismatch * FF_TAG_ERR;

// ------------------------------------------------------------
// Error case 1: FF_TAG_ERR
// ------------------------------------------------------------
pol FF_TAG_ERR = (sel_op_div + sel_op_not + SHIFT_OPS) * sel_is_ff + sel_op_fdiv * IS_NOT_FF;

// ------------------------------------------------------------
// Error case 2: sel_ab_tag_mismatch
// ------------------------------------------------------------
pol AB_TAGS_EQ = 1 - sel_ab_tag_mismatch;
pol commit ab_tags_diff_inv;
// sel_ab_tag_mismatch = 1 <==> ia_tag - ib_tag != 0
// For truncation both tags are not expected to match:
#[AB_TAGS_CHECK]
(1 - sel_op_truncate) * ( (ia_tag - ib_tag) * ( AB_TAGS_EQ * (1 - ab_tags_diff_inv) + ab_tags_diff_inv) - 1 + AB_TAGS_EQ ) = 0;

// For NOT and TRUNCATE, we need to unconditionally exclude a mismatched tag error.
// For NOT opcode, an error occurs if the tag of a is FF. In this case, tracegen will set b's (the output) tag as 0 (FF)
// which, in turn, will cause sel_ab_tag_mismatch to be 0.
// Note that the execution dispatching lookups for TRUNCATE (SET/CAST) ignores sel_err anyway, but
// we include it here for completeness (overhead is negligible).
#[ONLY_RELEVANT_CHECK_AB_TAGS_ERROR]
(sel_op_not + sel_op_truncate) * sel_ab_tag_mismatch = 0;

// ------------------------------------------------------------
// Error case 3: sel_div_0_err
// ------------------------------------------------------------
// DIV_OPS == 1 ==> [sel_div_0_err == 1 <==> ib == 0]
pol commit b_inv; // zero-check inverse helper column.
#[DIV_0_ERR]
DIV_OPS * (ib * (sel_div_0_err * (1 - b_inv) + b_inv) + sel_div_0_err - 1) = 0;

// DIV_OPS == 0 ==> sel_div_0_err == 0
#[ONLY_RELEVANT_CHECK_DIV_0_ERR_ERROR]
(1 - DIV_OPS) * sel_div_0_err = 0;

/******************************************************************************
* Other helper columns and output tag checking.
******************************************************************************/
// carry flag
pol commit cf; // @boolean
cf * (1 - cf) = 0;

// Generic helper column
// Current use: DIV (remainder), and SHL (2**ib)
pol commit helper1;

// maximum bits the number can hold (i.e. 8 for a u8) but 0 for FF:
pol commit max_bits;
// maximum value the number can hold (i.e. 255 for a u8), we use `max_value + 1` as modulus for the corresponding tag. For each integral tag,
// the modulus is `2^max_bits - 1`. For FF, `max_value == p - 1`.
pol commit max_value;

#[TAG_MAX_BITS_VALUE]
sel { ia_tag, max_bits, max_value } in precomputed.sel_tag_parameters { precomputed.clk, precomputed.tag_max_bits, precomputed.tag_max_value };

// OUTPUT TAG CHECKING

// NOT opccode does not mandate a specific tag for ic because the output is in ib.
pol EXPECTED_C_TAG = (sel_op_add + sel_op_sub + sel_op_mul + sel_op_div + sel_op_truncate + SHIFT_OPS) * ia_tag
                   + (sel_op_eq + sel_op_lt + sel_op_lte) * constants.MEM_TAG_U1 + sel_op_fdiv * constants.MEM_TAG_FF;

// The tag of c is generated by the opcode and is never wrong.
// Gating with (1 - sel_err) is necessary because when an error occurs, we have to set the tag to 0,
// which might not be equal to EXPECTED_C_TAG.
#[C_TAG_CHECK]
(1 - sel_err) * (EXPECTED_C_TAG - ic_tag) = 0;

// ALIASES FOR MUL AND DIV

// sel_op_mul & sel_is_u128 & sel_err == 0:
pol SEL_MUL_U128 = sel_op_mul * sel_is_u128 * (1 - sel_err);

// sel_op_div & sel_is_u128 & sel_err == 0:
pol SEL_DIV_U128 = sel_div_no_err * sel_is_u128;

/******************************************************************************
* BIT DECOMPOSITION (Common helper for MUL, DIV, SHL, SHR)
******************************************************************************/
// We use the below to prove correct decomposition of some values into limbs. Currently used by MUL, DIV, SHL, and SHR.
pol commit sel_decompose_a; // @boolean by definition and mutual exclusion of opcode selectors.
sel_decompose_a = (1 - sel_err) * (sel_mul_div_u128 + SHIFT_OPS);
// Currently, sel_decompose_b would just equal sel_mul_div_u128, so no need for another column.
pol commit a_lo, a_hi, b_lo, b_hi; // Limbs of the decomposed value. Range values defined by LIMB_SIZE.
pol TWO_POW_64 = 2 ** 64;

// Reusing columns for decomposition (#[OP_ID_CHECK] ensures selectors are mutually exclusive):
pol DECOMPOSED_A = (sel_op_mul * sel_is_u128 + sel_shift_ops_no_overflow) * ia + (SHIFT_OPS - sel_shift_ops_no_overflow) * (ib - max_bits) + sel_op_div * sel_is_u128 * ic;
pol DECOMPOSED_B = ib;
// For MUL and DIV, we decompose into 64 bit limbs. For shifts, we have one limb of b bits and one limb of max_bits - b bits.
pol LIMB_SIZE = sel_mul_div_u128 * TWO_POW_64 + SHIFT_OPS * sel_shift_ops_no_overflow * two_pow_shift_lo_bits;

#[A_DECOMPOSITION]
sel_decompose_a * (DECOMPOSED_A - (a_lo + LIMB_SIZE * a_hi)) = 0;
#[B_DECOMPOSITION]
sel_mul_div_u128 * (DECOMPOSED_B - (b_lo + LIMB_SIZE * b_hi)) = 0;

// Note: the only current use for decomposition of b has 64 bit limbs, so no need for b_lo/hi_bits.
pol commit a_lo_bits, a_hi_bits;
// TODO: Once lookups support expression in tuple, we can inline constant_64 into the lookup.
// Note: only currently used for MUL/DIV u128, so gated by sel_mul_div_u128:
pol commit constant_64;
sel_mul_div_u128 * (64 - constant_64) = 0;

#[A_LO_BITS]
a_lo_bits - sel_mul_div_u128 * constant_64 - SHIFT_OPS * shift_lo_bits = 0;

#[A_HI_BITS]
a_hi_bits - sel_mul_div_u128 * constant_64 - SHIFT_OPS * SHIFT_HI_BITS = 0;

#[RANGE_CHECK_DECOMPOSITION_A_LO]
sel_decompose_a { a_lo, a_lo_bits } in range_check.sel_alu { range_check.value, range_check.rng_chk_bits };

#[RANGE_CHECK_DECOMPOSITION_A_HI]
sel_decompose_a { a_hi, a_hi_bits } in range_check.sel_alu { range_check.value, range_check.rng_chk_bits };

#[RANGE_CHECK_DECOMPOSITION_B_LO]
sel_mul_div_u128 { b_lo, constant_64 } in range_check.sel_alu { range_check.value, range_check.rng_chk_bits };

#[RANGE_CHECK_DECOMPOSITION_B_HI]
sel_mul_div_u128 { b_hi, constant_64 } in range_check.sel_alu { range_check.value, range_check.rng_chk_bits };

/******************************************************************************
* Opcode Computations
******************************************************************************/
// ------------------------------------------------------------
// ADD & SUB
// ------------------------------------------------------------
// For add, sel_op_add - sel_op_sub = 1 => check a + b - cf * 2^(max_bits) = c
// For sub, sel_op_add - sel_op_sub = -1 => check a - b + cf * 2^(max_bits) = c
// Though in this circuit we could incorrectly set cf = 0 when we would overflow
// the memory range check would catch that c is too large (see preconditions).
#[ALU_ADD_SUB]
(sel_op_add + sel_op_sub) * (1 - sel_err) * (ia - ic + (sel_op_add - sel_op_sub) * (ib - cf * (max_value + 1))) = 0;

// ------------------------------------------------------------
// MUL
// ------------------------------------------------------------
pol commit c_hi; // Helper value limb of 64 bits.

// MUL - non u128

// For non-u128 and non-ff values, we have a*b < 2^128 and
// c = a * b - c_hi * 2^max_bits for a unique c_hi < 2^max_bits <= 2^64.
// It is fine to range check c_hi < 2^64 for smaller tags because c_hi * 2^max_bits
// cannot overflow the field (product < 2^128).
// Range check for c_hi is performed below in #[RANGE_CHECK_MUL_C_HI].
// For FF values, max_values + 1 = 0 and the relation is trivially satisfied no matter
// which c_hi we choose. Our tracegen sets c_hi to 0 for FF values.
#[ALU_MUL_NON_U128]
sel_op_mul * IS_NOT_U128 * (1 - sel_err) * (ia * ib - ic - (max_value + 1) * c_hi) = 0;

// MUL - u128

// We express a, b in 64-bit slices: a = a_lo + a_hi * 2^64
//                                   b = b_lo + b_hi * 2^64
// => a * b = a_lo * b_lo + (a_hi * b_lo + a_lo * b_hi) * 2^64 + (a_hi * b_hi) * 2^128 = c_hi_full * 2^128 + c
// for c_hi_full and c being 128-bit limbs. We can remove the term a_hi * b_hi * 2^128 when working modulo 2^128
// and to avoid handling field overflows. We rewrite the relation as:
// a * b_lo + a_lo * b_hi * 2^64 = (cf * 2^64 + c_hi) * 2^128 + c for a bit cf and c_hi < 2^64.
// Namely, the left hand side is strictly less than 2 * 2^192.
// c_hi can be computed explicitly as (c_hi_full - (a_hi * b_hi)) % 2^64 and
// cf == 1 iff c_hi_full - (a_hi * b_hi) >= 2^64 equivalently cf == (c_hi_full - (a_hi * b_hi)) / 2^64.

#[ALU_MUL_U128]
SEL_MUL_U128 * (
        ia * b_lo + a_lo * b_hi * TWO_POW_64            // a * b without the hi bits
        - ic                                            // c_lo
        - (max_value + 1) * (cf * TWO_POW_64 + c_hi)    // c_hi * 2^128 + (cf ? 2^192 : 0)
    ) = 0;

// We need to range check c_hi < 2^64 for non-FF values and when there is no error.
pol commit sel_mul_no_err_non_ff; // @boolean Follows from definition.
sel_mul_no_err_non_ff = IS_NOT_FF * (1 - sel_err) * sel_op_mul;
#[RANGE_CHECK_MUL_C_HI]
sel_mul_no_err_non_ff { c_hi, constant_64 } in range_check.sel_alu { range_check.value, range_check.rng_chk_bits };

// ------------------------------------------------------------
// DIV & FDIV
// ------------------------------------------------------------
pol commit sel_div_no_err; // @boolean Follows from definition.
sel_div_no_err = sel_op_div * (1 - sel_err);
// We need to show that remainder < b (remainder stored in helper1)
// We use #[INT_GT] below (see LT/LTE) by setting gt_input_a = b, gt_input_b = helper1, gt_result_c = 1 (gated by sel_div_no_err).

// DIV - u128

// Using this to switch on the range checks for decomposed u128 integers (#[OP_ID_CHECK] ensures selectors are mutually exclusive)
pol commit sel_mul_div_u128; // @boolean Follows from definition.
// SEL_MUL_U128 || SEL_DIV_U128
sel_mul_div_u128 = SEL_MUL_U128 + SEL_DIV_U128;

// We share the logic from MUL, since here we also must show a product evaluates to a result:
//  c * b = a - remainder

// We express c, b in 64-bit slices: c = c_lo + c_hi * 2^64
//                                   b = b_lo + b_hi * 2^64
// => c * b = c_lo * b_lo + (c_hi * b_lo + c_lo * b_hi) * 2^64 + (c_hi * b_hi) * 2^128 = a - r
// => the 'top bits' of the LHS are given by (c_hi * b_hi) * 2^128
// For a happy path of 128 bit integer division (a / b = c), we cannot have both b and c > 64 bits
//  => c_hi * b_hi = 0 (see ALU_DIV_U128_CHECK)
//  => above is equivalent to:
// c_lo * b_lo + (c_hi * b_lo + c_lo * b_hi) * 2^64 = a - r
// c * b_lo + c_lo * b_hi * 2^64 = a - r

// We do not need to decompose a - r because the LHS is constrained to be < 192 bits, protecting against
// field underflows.

// Reuse columns b_lo, b_hi from MUL above to represent b (see B_DECOMPOSITION)
// Reuse columns a_lo, a_hi from MUL above to represent c (see A_DECOMPOSITION)

#[ALU_DIV_U128_CHECK]
SEL_DIV_U128 * a_hi * b_hi = 0;

#[ALU_DIV_U128]
SEL_DIV_U128 * (ic * b_lo + a_lo * b_hi * TWO_POW_64 - (ia - helper1)) = 0;

// FDIV

// For FDIV, we reuse the same main relation for non-u128 DIV (ALU_FDIV_DIV_NON_U128) but constrain that there is no remainder, stored in helper1.
// => The relation shows that b * c = a for FF

// DIV & FDIV - shared ops

// DIV & FDIV - non u128

pol DIV_OPS_NON_U128 = (1 - sel_err) * sel_op_fdiv + sel_div_no_err * IS_NOT_U128;

// Show a - remainder = b * c
// Note: Since a, b, c, and remainder are under 64 bits (or remainder == 0 for FF), we are protected against a - remainder underflowing,
// i.e. b * c (< 128bits) cannot equal underflowed a - remainder (> 253 bits)
#[ALU_FDIV_DIV_NON_U128]
DIV_OPS_NON_U128 * (ib * ic - ia + sel_op_div * helper1) = 0;

// ------------------------------------------------------------
// EQ
// ------------------------------------------------------------

pol DIFF = ia - ib;
pol commit ab_diff_inv; // Helper column for inverting DIFF.
// ic is a boolean output and ic == 1 <==> a == b.
// Important: ic boolean constraint is enforced as part of write to memory due to ic_tag == U1 as enforced by #[C_TAG_CHECK].

// sel_op_eq == 1 => [ic == 1 <==> DIFF == 0]
#[EQ_OP_MAIN]
sel_op_eq * (1 - sel_err) * (DIFF * (ic * (1 - ab_diff_inv) + ab_diff_inv) - 1 + ic) = 0;

// ------------------------------------------------------------
// LT & LTE + `Greater Than` helper for DIV
// ------------------------------------------------------------
pol SEL_LT_OPS = (1 - sel_err) * (sel_op_lt + sel_op_lte);

pol commit sel_ff_gt; // @boolean Follows from definition.
// sel_is_ff & SEL_LT_OPS:
sel_ff_gt = sel_is_ff * SEL_LT_OPS;

pol commit sel_int_gt; // @boolean Follows from definition.
// (!sel_is_ff & SEL_LT_OPS) || sel_div_no_err:
sel_int_gt = IS_NOT_FF * SEL_LT_OPS + sel_div_no_err;

// To perform LT or LTE ops, we redirect to the GT gadget where we check gt_input_a > gt_input_b ? gt_result_c:
//  For LT, we want to show that: a < b ? c, so we use GT with swapped inputs and check: b > a ? c
//      LT: gt_input_a = ib, gt_input_b = ia, gt_result_c = ic
//  For LTE, we want to show that: a <= b ? c, so we use GT with values as they are input and negate the result: a > b ? !c
//      LTE: gt_input_a = ia, gt_input_b = ib, gt_result_c = !ic
pol commit gt_input_a, gt_input_b;
pol commit gt_result_c; // @boolean (guaranteed by gt and ff_gt gadget return value)
                        // Unconstrained if SEL_LT_OPS == 0 or sel_div_no_err == 0.

#[GT_INPUT_A]
gt_input_a = (sel_op_lt + sel_div_no_err) * ib + sel_op_lte * ia;

#[GT_INPUT_B]
gt_input_b = sel_op_lt * ia + sel_op_lte * ib + sel_div_no_err * helper1;

#[GT_ASSIGN_RESULT_C]
(1 - sel_err) * (sel_div_no_err + sel_op_lt * ic + sel_op_lte * (1 - ic) - gt_result_c) = 0;

#[FF_GT]
sel_ff_gt { gt_input_a, gt_input_b, gt_result_c }
in ff_gt.sel_gt { ff_gt.a, ff_gt.b, ff_gt.result };

#[INT_GT]
sel_int_gt { gt_input_a, gt_input_b, gt_result_c }
in gt.sel_alu { gt.input_a, gt.input_b, gt.res };

// ------------------------------------------------------------
// NOT
// ------------------------------------------------------------
// Input is sent to ia, ia_tag and output is sent to ib, ib_tag.

// Relation is: a + ~a = 2^k - 1, where k is the number of bits in a.
#[NOT_OP_MAIN]
sel_op_not * (1 - sel_err) * (ia + ib - max_value) = 0;

// ------------------------------------------------------------
// SHL & SHR
// ------------------------------------------------------------
// Given (1) an input a, within the range [0, 2**128-1],
//       (2) a value s, the amount of bits to shift a by (stored in ib),
//       (3) and a memory tag, mem_tag that supports a maximum of t bits (stored in max_bits).
// Split input a into Big Endian hi and lo limbs, (we re-use the a_hi and a_lo columns we used for the MUL/DIV u128 operators)
// a_hi and a_lo, and the number of bits represented by the memory tag, t. ( memory tag ensures a < 2**t).
// If we are shifting by more than the bit length represented by the memory tag, the result is trivially zero.

// Error gating: We gate the relations below by (1 - sel_err), so that all column values specific to
// SHL/SHR computations can be set to zero. While it might be possible to relax some of these gating,
// we favor simplicity and clarity over potential performance gains.

// SHL

// === Steps when performing SHL
// (1) Prove the correct decomposition: a_hi * 2**(t-s) + a_lo = a ---> see #[A_DECOMPOSITION]
// (2) Range check a_hi < 2**s && a_lo < 2**(t-s)                  ---> see #[RANGE_CHECK_DECOMPOSITION_A_LO/HI]
// (3) Return a_lo * 2**s                                          ---> see #[ALU_SHL]
//
//  <-- s bits -->   | <-- (t-s) bits -->
// ------------------|-------------------
// |      a_hi       |      a_lo        | --> output = a_lo * 2**s
// --------------------------------------
//
// Use of helper1 for SHL:
//  We have: s (=ib), t (=max_bits), 2**(t-s) (=two_pow_shift_lo_bits), and 2**t (=max_value + 1)
//  We want: 2**s (=2**ib), ideally without another precomputed.power_of_2 lookup
//  Injecting 2**s (=helper1), we can check that 2**t == 2**(t-s) * 2**s:
#[SHL_TWO_POW_SHIFT]
sel_op_shl * sel_shift_ops_no_overflow * (1 - sel_err) * (max_value + 1 - two_pow_shift_lo_bits * helper1) = 0;

#[ALU_SHL]
sel_op_shl * (1 - sel_err) * (ic - sel_shift_ops_no_overflow * a_lo * helper1) = 0;

// SHR

// === Steps when performing SHR
// (1) Prove the correct decomposition: a_hi * 2**s + a_lo = a ---> see #[A_DECOMPOSITION]
// (2) Range check a_hi < 2**(t-s) && a_lo < 2**s              ---> see #[RANGE_CHECK_DECOMPOSITION_A_LO/HI]
// (3) Return a_hi                                             ---> see #[ALU_SHR]
//
//  <--(t-s) bits --> |   <-- s bits -->
// -------------------|-------------------
// |      a_hi        |       a_lo       | --> output = a_hi
// ---------------------------------------

#[ALU_SHR]
sel_op_shr * (1 - sel_err) * (ic - sel_shift_ops_no_overflow * a_hi) = 0;

// SHL & SHR - Shared relations:

pol commit sel_shift_ops_no_overflow; // @boolean
sel_shift_ops_no_overflow * (1 - sel_shift_ops_no_overflow) = 0;
// sel_shift_ops_no_overflow = 1 ==> SHIFT_OPS = 1:
sel_shift_ops_no_overflow * (1 - SHIFT_OPS) = 0;
// (sel_op_shl || sel_op_shr) & b < max_bits: see below* for constraining.
pol SHIFT_OVERFLOW = SHIFT_OPS * (1 - sel_shift_ops_no_overflow);

// The bit size of the lo limb used by the shift:
pol commit shift_lo_bits;
pol commit two_pow_shift_lo_bits;

// *For SHL and SHR, when the shift `b > max_bits` we want SHIFT_OVERFLOW == 1 and c == 0:
//  SHL: shift_lo_bits = max_bits - b -> will underflow
//  SHR: SHIFT_HI_BITS = max_bits - b -> will underflow
//  so instead set a_lo = b - max_bits and shift_lo_bits = max_bits for both SHL and SHR (see DECOMPOSED_A) and reuse the range check
//  RANGE_CHECK_DECOMPOSITION_A_LO to prove that b >= max_bits when SHIFT_OVERFLOW = 1.

#[SHIFTS_LO_BITS]
shift_lo_bits = (1 - sel_err) * (
    sel_shift_ops_no_overflow * (sel_op_shl * (max_bits - ib) + sel_op_shr * ib)
  + SHIFT_OVERFLOW * max_bits
);

// Set shift_hi_bits = max_bits in the overflow case, so RANGE_CHECK_DECOMPOSITION_A_HI passes. Since we set c == 0 in this case,
// we don't need to constrain that a_hi is within a certain limb size.
pol SHIFT_HI_BITS = (1 - sel_err) * (max_bits - sel_shift_ops_no_overflow * shift_lo_bits);

#[SHIFTS_TWO_POW]
sel_shift_ops_no_overflow { shift_lo_bits, two_pow_shift_lo_bits } in precomputed.sel_range_8 { precomputed.clk, precomputed.power_of_2 };

// Note on why sel_shift_ops_no_overflow is correctly constrained:
// 1) If ib < max_bits and we maliciously set sel_shift_ops_no_overflow == 0,
// then a_lo == ib - max_bits, (DECOMPOSED_A == ib - max_bits, LIMB_SIZE == 0)
// and the range check on a_lo_bits = max_bits will fail as a_lo > 128 bits.
// 2) If ib > max_bits and we maliciously set sel_shift_ops_no_overflow == 1,
// then shift_lo_bits == max_bits - ib for SHL and the lookup #[SHIFTS_TWO_POW]
// cannot be satisified. For SHR, a_hi_bits == SHIFT_HI_BITS == max_bits - ib
// and the range check #[RANGE_CHECK_DECOMPOSITION_A_HI] with a huge rng_chk_bits
// cannnot be satisfied.
// Note that for the edge case ib == max_bits, we can either set sel_shift_ops_no_overflow == 0 or 1,
// as both cases can satisfy the relations. Note that our tracegen will handle this case
// as not an overflow i.e., sel_shift_ops_no_overflow == 1.

// ------------------------------------------------------------
// TRUNCATE
// ------------------------------------------------------------
// TRUNCATE: ALU part for opcodes CAST and SET
// Input of truncation value is sent to ia, destination tag in ia_tag and output is computed as ic.
// We have one dispatching lookup from execution specific to CAST and another one for SET, as
// the layout for registers and operands strongly differ from other ALU opcodes.
// The truncation operates on the FF value of the input and we completely ignore its tag, therefore
// the tag of the input is in general not equal to ia_tag.

// 3 cases for truncation:
// - No truncation required (ia <= max_value)
// - truncation for ia >= 2^128
// - truncation for ia < 2^128
pol commit sel_trunc_trivial; // @boolean
pol commit sel_trunc_gte_128; // @boolean
pol commit sel_trunc_lt_128; // @boolean

// If ia >= 2^128 and dst_tag != FF, and a malicious sequencer toggled sel_trunc_trivial, this would
// fail in the range check pertaining to the memory write. If the sequencer toggled sel_trunc_lt_128,
// this would fail in the decomposition of ia == lo_128 in #[TRUNC_LO_128_DECOMPOSITION], because
// the range checks on mid and ic (memory write) ensure a correct 128-bit decomposition of ia.
// If ia < 2^128 and ia > max_value, and a malicious sequencer toggled sel_trunc_trivial,
// then the memory write would fail because ia == ic > max_value.

// Boolean
sel_trunc_trivial * (1 - sel_trunc_trivial) = 0;
sel_trunc_gte_128 * (1 - sel_trunc_gte_128) = 0;
sel_trunc_lt_128 * (1 - sel_trunc_lt_128) = 0;

// Truncation separation case
// Mutually exclusive due to sel_op_truncate being boolean
pol commit sel_trunc_non_trivial; // @boolean Follows from definition. TODO: Aliases this once lookups support aliases for selectors.

#[SEL_TRUNC_NON_TRIVIAL]
sel_trunc_non_trivial = sel_trunc_gte_128 + sel_trunc_lt_128;

#[SEL_TRUNCATE]
sel_op_truncate = sel_trunc_non_trivial + sel_trunc_trivial;

// Trivial case: (the constraint that ic <= max_value is enforced by the memory write)
#[TRUNC_TRIVIAL_CASE]
sel_trunc_trivial * (ia - ic) = 0;

// NOTE: reusing a_lo column from MUL in TRUNC:
// For truncate, a_lo = 128-bit low limb of ia.
// mid is a limb of `128 - max_bits` bits.
pol commit mid;

// Note that we do not need to fetch the 128-bit high limb of ia. We invoke
// ff_gt.sel_dec to ensure that a_lo is correct. (Inside of ff_gt gadget, the
// high limb will be computed and proven to be correct.)
#[LARGE_TRUNC_CANONICAL_DEC]
sel_trunc_gte_128 { ia, a_lo}
in
ff_gt.sel_dec { ff_gt.a, ff_gt.a_lo };

#[SMALL_TRUNC_VAL_IS_LO]
sel_trunc_lt_128 * (a_lo - ia) = 0;

// a_lo = ic + mid * 2^ia_tag_bits, where 2^ia_tag_bits is max_value + 1.
#[TRUNC_LO_128_DECOMPOSITION]
sel_trunc_non_trivial * (ic + mid * (max_value + 1) - a_lo) = 0;

// TODO: Once lookups support expression in tuple, we can inline mid_bits into the lookup.
pol commit mid_bits;
#[TRUNC_MID_BITS]
mid_bits = sel_trunc_non_trivial * (128 - max_bits);

// Note that for ia_tag == U128 the range check is trivial (0, 0) but
// is supported by our range_check gadget.
// No need to range_check ic because the memory write will ensure ic <= max_value.
#[RANGE_CHECK_TRUNC_MID]
sel_trunc_non_trivial { mid, mid_bits } in range_check.sel_alu { range_check.value, range_check.rng_chk_bits };
