// WARNING: FILE CODE GENERATED BY BINDGEN UTILITY. DO NOT EDIT!
/* eslint-disable @typescript-eslint/no-unused-vars */
import { BarretenbergBinder, BarretenbergBinderSync } from '../barretenberg_binder/index.js';
import { BufferDeserializer, NumberDeserializer, VectorDeserializer, BoolDeserializer, StringDeserializer } from '../serialize/index.js';
import { Fr, Fq, Point, Buffer32, Buffer128, Ptr } from '../types/index.js';

export class BarretenbergApi {
  constructor(public binder: BarretenbergBinder) {}

  async destroy() {
    await this.binder.wasm.destroy();
  }

  async pedersenInit(): Promise<void> {
    const result = await this.binder.callWasmExport('pedersen_init', [], []);
    return;
  }

  async pedersenCompressFields(left: Fr, right: Fr): Promise<Fr> {
    const result = await this.binder.callWasmExport('pedersen_compress_fields', [left, right], [Fr]);
    return result[0];
  }

  async pedersenPlookupCompressFields(left: Fr, right: Fr): Promise<Fr> {
    const result = await this.binder.callWasmExport('pedersen_plookup_compress_fields', [left, right], [Fr]);
    return result[0];
  }

  async pedersenCompress(inputsBuffer: Fr[]): Promise<Fr> {
    const result = await this.binder.callWasmExport('pedersen_compress', [inputsBuffer], [Fr]);
    return result[0];
  }

  async pedersenPlookupCompress(inputsBuffer: Fr[]): Promise<Fr> {
    const result = await this.binder.callWasmExport('pedersen_plookup_compress', [inputsBuffer], [Fr]);
    return result[0];
  }

  async pedersenCompressWithHashIndex(inputsBuffer: Fr[], hashIndex: number): Promise<Fr> {
    const result = await this.binder.callWasmExport('pedersen_compress_with_hash_index', [inputsBuffer, hashIndex], [Fr]);
    return result[0];
  }

  async pedersenCommit(inputsBuffer: Fr[]): Promise<Fr> {
    const result = await this.binder.callWasmExport('pedersen_commit', [inputsBuffer], [Fr]);
    return result[0];
  }

  async pedersenPlookupCommit(inputsBuffer: Fr[]): Promise<Fr> {
    const result = await this.binder.callWasmExport('pedersen_plookup_commit', [inputsBuffer], [Fr]);
    return result[0];
  }

  async pedersenBufferToField(data: Uint8Array): Promise<Fr> {
    const result = await this.binder.callWasmExport('pedersen_buffer_to_field', [data], [Fr]);
    return result[0];
  }

  async pedersenHashInit(): Promise<void> {
    const result = await this.binder.callWasmExport('pedersen_hash_init', [], []);
    return;
  }

  async pedersenHashPair(left: Fr, right: Fr): Promise<Fr> {
    const result = await this.binder.callWasmExport('pedersen_hash_pair', [left, right], [Fr]);
    return result[0];
  }

  async pedersenHashMultiple(inputsBuffer: Fr[]): Promise<Fr> {
    const result = await this.binder.callWasmExport('pedersen_hash_multiple', [inputsBuffer], [Fr]);
    return result[0];
  }

  async pedersenHashMultipleWithHashIndex(inputsBuffer: Fr[], hashIndex: number): Promise<Fr> {
    const result = await this.binder.callWasmExport('pedersen_hash_multiple_with_hash_index', [inputsBuffer, hashIndex], [Fr]);
    return result[0];
  }

  async pedersenHashToTree(data: Fr[]): Promise<Fr[]> {
    const result = await this.binder.callWasmExport('pedersen_hash_to_tree', [data], [VectorDeserializer(Fr)]);
    return result[0];
  }

  async blake2s(data: Uint8Array): Promise<Buffer32> {
    const result = await this.binder.callWasmExport('blake2s', [data], [Buffer32]);
    return result[0];
  }

  async blake2sToField(data: Uint8Array): Promise<Fr> {
    const result = await this.binder.callWasmExport('blake2s_to_field_', [data], [Fr]);
    return result[0];
  }

  async schnorrComputePublicKey(privateKey: Fr): Promise<Point> {
    const result = await this.binder.callWasmExport('schnorr_compute_public_key', [privateKey], [Point]);
    return result[0];
  }

  async schnorrNegatePublicKey(publicKeyBuffer: Point): Promise<Point> {
    const result = await this.binder.callWasmExport('schnorr_negate_public_key', [publicKeyBuffer], [Point]);
    return result[0];
  }

  async schnorrConstructSignature(message: Uint8Array, privateKey: Fr): Promise<[Buffer32, Buffer32]> {
    const result = await this.binder.callWasmExport('schnorr_construct_signature', [message, privateKey], [Buffer32, Buffer32]);
    return result as any;
  }

  async schnorrVerifySignature(message: Uint8Array, pubKey: Point, sigS: Buffer32, sigE: Buffer32): Promise<boolean> {
    const result = await this.binder.callWasmExport('schnorr_verify_signature', [message, pubKey, sigS, sigE], [BoolDeserializer()]);
    return result[0];
  }

  async schnorrMultisigCreateMultisigPublicKey(privateKey: Fq): Promise<Buffer128> {
    const result = await this.binder.callWasmExport('schnorr_multisig_create_multisig_public_key', [privateKey], [Buffer128]);
    return result[0];
  }

  async schnorrMultisigValidateAndCombineSignerPubkeys(signerPubkeyBuf: Buffer128[]): Promise<[Point, boolean]> {
    const result = await this.binder.callWasmExport('schnorr_multisig_validate_and_combine_signer_pubkeys', [signerPubkeyBuf], [Point, BoolDeserializer()]);
    return result as any;
  }

  async schnorrMultisigConstructSignatureRound1(): Promise<[Buffer128, Buffer128]> {
    const result = await this.binder.callWasmExport('schnorr_multisig_construct_signature_round_1', [], [Buffer128, Buffer128]);
    return result as any;
  }

  async schnorrMultisigConstructSignatureRound2(message: Uint8Array, privateKey: Fq, signerRoundOnePrivateBuf: Buffer128, signerPubkeysBuf: Buffer128[], roundOnePublicBuf: Buffer128[]): Promise<[Fq, boolean]> {
    const result = await this.binder.callWasmExport('schnorr_multisig_construct_signature_round_2', [message, privateKey, signerRoundOnePrivateBuf, signerPubkeysBuf, roundOnePublicBuf], [Fq, BoolDeserializer()]);
    return result as any;
  }

  async schnorrMultisigCombineSignatures(message: Uint8Array, signerPubkeysBuf: Buffer128[], roundOneBuf: Buffer128[], roundTwoBuf: Fr[]): Promise<[Buffer32, Buffer32, boolean]> {
    const result = await this.binder.callWasmExport('schnorr_multisig_combine_signatures', [message, signerPubkeysBuf, roundOneBuf, roundTwoBuf], [Buffer32, Buffer32, BoolDeserializer()]);
    return result as any;
  }

  async eccNewPippenger(points: Uint8Array, numPointsBuf: number): Promise<Ptr> {
    const result = await this.binder.callWasmExport('ecc_new_pippenger', [points, numPointsBuf], [Ptr]);
    return result[0];
  }

  async eccNewPippengerMemPrealloced(points: Ptr, numPoints: number): Promise<Ptr> {
    const result = await this.binder.callWasmExport('ecc_new_pippenger_mem_prealloced', [points, numPoints], [Ptr]);
    return result[0];
  }

  async eccDeletePippenger(pippenger: Ptr): Promise<void> {
    const result = await this.binder.callWasmExport('ecc_delete_pippenger', [pippenger], []);
    return;
  }

  async eccPippengerUnsafe(pippengerPtr: Ptr, scalarsPtr: Ptr, from: number, range: number): Promise<Point> {
    const result = await this.binder.callWasmExport('ecc_pippenger_unsafe', [pippengerPtr, scalarsPtr, from, range], [Point]);
    return result[0];
  }

  async eccG1Sum(pointsPtr: Ptr, numPoints: number): Promise<Point> {
    const result = await this.binder.callWasmExport('ecc_g1_sum', [pointsPtr, numPoints], [Point]);
    return result[0];
  }

  async examplesSimpleCreateAndVerifyProof(pippenger: Ptr, g2x: Uint8Array): Promise<boolean> {
    const result = await this.binder.callWasmExport('examples_simple_create_and_verify_proof', [pippenger, g2x], [BoolDeserializer()]);
    return result[0];
  }

  async testThreads(threads: number, iterations: number): Promise<number> {
    const result = await this.binder.callWasmExport('test_threads', [threads, iterations], [NumberDeserializer()]);
    return result[0];
  }

  async testThreadAbort(): Promise<void> {
    const result = await this.binder.callWasmExport('test_thread_abort', [], []);
    return;
  }

  async testAbort(): Promise<void> {
    const result = await this.binder.callWasmExport('test_abort', [], []);
    return;
  }

  async commonInitSlabAllocator(circuitSize: number): Promise<void> {
    const result = await this.binder.callWasmExport('common_init_slab_allocator', [circuitSize], []);
    return;
  }

  async acirNewAcirComposer(pippenger: Ptr, g2x: Uint8Array): Promise<Ptr> {
    const result = await this.binder.callWasmExport('acir_new_acir_composer', [pippenger, g2x], [Ptr]);
    return result[0];
  }

  async acirDeleteAcirComposer(acirComposerPtr: Ptr): Promise<void> {
    const result = await this.binder.callWasmExport('acir_delete_acir_composer', [acirComposerPtr], []);
    return;
  }

  async acirInitProvingKey(acirComposerPtr: Ptr, constraintSystemBuf: Uint8Array, sizeHint: number): Promise<void> {
    const result = await this.binder.callWasmExport('acir_init_proving_key', [acirComposerPtr, constraintSystemBuf, sizeHint], []);
    return;
  }

  async acirCreateProof(acirComposerPtr: Ptr, constraintSystemBuf: Uint8Array, witnessBuf: Uint8Array, isRecursive: boolean): Promise<Uint8Array> {
    const result = await this.binder.callWasmExport('acir_create_proof', [acirComposerPtr, constraintSystemBuf, witnessBuf, isRecursive], [BufferDeserializer()]);
    return result[0];
  }

  async acirInitVerificationKey(acirComposerPtr: Ptr): Promise<void> {
    const result = await this.binder.callWasmExport('acir_init_verification_key', [acirComposerPtr], []);
    return;
  }

  async acirVerifyProof(acirComposerPtr: Ptr, proofBuf: Uint8Array, isRecursive: boolean): Promise<boolean> {
    const result = await this.binder.callWasmExport('acir_verify_proof', [acirComposerPtr, proofBuf, isRecursive], [BoolDeserializer()]);
    return result[0];
  }

  async acirGetSolidityVerifier(acirComposerPtr: Ptr): Promise<string> {
    const result = await this.binder.callWasmExport('acir_get_solidity_verifier', [acirComposerPtr], [StringDeserializer()]);
    return result[0];
  }

  async acirGetExactCircuitSize(acirComposerPtr: Ptr): Promise<number> {
    const result = await this.binder.callWasmExport('acir_get_exact_circuit_size', [acirComposerPtr], [NumberDeserializer()]);
    return result[0];
  }

  async acirGetTotalCircuitSize(acirComposerPtr: Ptr): Promise<number> {
    const result = await this.binder.callWasmExport('acir_get_total_circuit_size', [acirComposerPtr], [NumberDeserializer()]);
    return result[0];
  }

  async acirVerifyRecursiveProof(acirComposerPtr: Ptr, proofBuf: Uint8Array, numInnerPublicInputs: number): Promise<Uint8Array> {
    const result = await this.binder.callWasmExport('acir_verify_recursive_proof', [acirComposerPtr, proofBuf, numInnerPublicInputs], [BufferDeserializer()]);
    return result[0];
  }

  async acirSerializeProofIntoFields(acirComposerPtr: Ptr, proofBuf: Uint8Array, numInnerPublicInputs: number): Promise<Uint8Array> {
    const result = await this.binder.callWasmExport('acir_serialize_proof_into_fields', [acirComposerPtr, proofBuf, numInnerPublicInputs], [BufferDeserializer()]);
    return result[0];
  }

  async acirSerializeVerificationKeyIntoFields(acirComposerPtr: Ptr): Promise<[Uint8Array, Uint8Array]> {
    const result = await this.binder.callWasmExport('acir_serialize_verification_key_into_fields', [acirComposerPtr], [BufferDeserializer(), BufferDeserializer()]);
    return result as any;
  }
}

export class BarretenbergApiSync {
  constructor(public binder: BarretenbergBinderSync) {}

  async destroy() {
    await this.binder.wasm.destroy();
  }

  pedersenInit(): void {
    const result = this.binder.callWasmExport('pedersen_init', [], []);
    return;
  }

  pedersenCompressFields(left: Fr, right: Fr): Fr {
    const result = this.binder.callWasmExport('pedersen_compress_fields', [left, right], [Fr]);
    return result[0];
  }

  pedersenPlookupCompressFields(left: Fr, right: Fr): Fr {
    const result = this.binder.callWasmExport('pedersen_plookup_compress_fields', [left, right], [Fr]);
    return result[0];
  }

  pedersenCompress(inputsBuffer: Fr[]): Fr {
    const result = this.binder.callWasmExport('pedersen_compress', [inputsBuffer], [Fr]);
    return result[0];
  }

  pedersenPlookupCompress(inputsBuffer: Fr[]): Fr {
    const result = this.binder.callWasmExport('pedersen_plookup_compress', [inputsBuffer], [Fr]);
    return result[0];
  }

  pedersenCompressWithHashIndex(inputsBuffer: Fr[], hashIndex: number): Fr {
    const result = this.binder.callWasmExport('pedersen_compress_with_hash_index', [inputsBuffer, hashIndex], [Fr]);
    return result[0];
  }

  pedersenCommit(inputsBuffer: Fr[]): Fr {
    const result = this.binder.callWasmExport('pedersen_commit', [inputsBuffer], [Fr]);
    return result[0];
  }

  pedersenPlookupCommit(inputsBuffer: Fr[]): Fr {
    const result = this.binder.callWasmExport('pedersen_plookup_commit', [inputsBuffer], [Fr]);
    return result[0];
  }

  pedersenBufferToField(data: Uint8Array): Fr {
    const result = this.binder.callWasmExport('pedersen_buffer_to_field', [data], [Fr]);
    return result[0];
  }

  pedersenHashInit(): void {
    const result = this.binder.callWasmExport('pedersen_hash_init', [], []);
    return;
  }

  pedersenHashPair(left: Fr, right: Fr): Fr {
    const result = this.binder.callWasmExport('pedersen_hash_pair', [left, right], [Fr]);
    return result[0];
  }

  pedersenHashMultiple(inputsBuffer: Fr[]): Fr {
    const result = this.binder.callWasmExport('pedersen_hash_multiple', [inputsBuffer], [Fr]);
    return result[0];
  }

  pedersenHashMultipleWithHashIndex(inputsBuffer: Fr[], hashIndex: number): Fr {
    const result = this.binder.callWasmExport('pedersen_hash_multiple_with_hash_index', [inputsBuffer, hashIndex], [Fr]);
    return result[0];
  }

  pedersenHashToTree(data: Fr[]): Fr[] {
    const result = this.binder.callWasmExport('pedersen_hash_to_tree', [data], [VectorDeserializer(Fr)]);
    return result[0];
  }

  blake2s(data: Uint8Array): Buffer32 {
    const result = this.binder.callWasmExport('blake2s', [data], [Buffer32]);
    return result[0];
  }

  blake2sToField(data: Uint8Array): Fr {
    const result = this.binder.callWasmExport('blake2s_to_field_', [data], [Fr]);
    return result[0];
  }

  schnorrComputePublicKey(privateKey: Fr): Point {
    const result = this.binder.callWasmExport('schnorr_compute_public_key', [privateKey], [Point]);
    return result[0];
  }

  schnorrNegatePublicKey(publicKeyBuffer: Point): Point {
    const result = this.binder.callWasmExport('schnorr_negate_public_key', [publicKeyBuffer], [Point]);
    return result[0];
  }

  schnorrConstructSignature(message: Uint8Array, privateKey: Fr): [Buffer32, Buffer32] {
    const result = this.binder.callWasmExport('schnorr_construct_signature', [message, privateKey], [Buffer32, Buffer32]);
    return result as any;
  }

  schnorrVerifySignature(message: Uint8Array, pubKey: Point, sigS: Buffer32, sigE: Buffer32): boolean {
    const result = this.binder.callWasmExport('schnorr_verify_signature', [message, pubKey, sigS, sigE], [BoolDeserializer()]);
    return result[0];
  }

  schnorrMultisigCreateMultisigPublicKey(privateKey: Fq): Buffer128 {
    const result = this.binder.callWasmExport('schnorr_multisig_create_multisig_public_key', [privateKey], [Buffer128]);
    return result[0];
  }

  schnorrMultisigValidateAndCombineSignerPubkeys(signerPubkeyBuf: Buffer128[]): [Point, boolean] {
    const result = this.binder.callWasmExport('schnorr_multisig_validate_and_combine_signer_pubkeys', [signerPubkeyBuf], [Point, BoolDeserializer()]);
    return result as any;
  }

  schnorrMultisigConstructSignatureRound1(): [Buffer128, Buffer128] {
    const result = this.binder.callWasmExport('schnorr_multisig_construct_signature_round_1', [], [Buffer128, Buffer128]);
    return result as any;
  }

  schnorrMultisigConstructSignatureRound2(message: Uint8Array, privateKey: Fq, signerRoundOnePrivateBuf: Buffer128, signerPubkeysBuf: Buffer128[], roundOnePublicBuf: Buffer128[]): [Fq, boolean] {
    const result = this.binder.callWasmExport('schnorr_multisig_construct_signature_round_2', [message, privateKey, signerRoundOnePrivateBuf, signerPubkeysBuf, roundOnePublicBuf], [Fq, BoolDeserializer()]);
    return result as any;
  }

  schnorrMultisigCombineSignatures(message: Uint8Array, signerPubkeysBuf: Buffer128[], roundOneBuf: Buffer128[], roundTwoBuf: Fr[]): [Buffer32, Buffer32, boolean] {
    const result = this.binder.callWasmExport('schnorr_multisig_combine_signatures', [message, signerPubkeysBuf, roundOneBuf, roundTwoBuf], [Buffer32, Buffer32, BoolDeserializer()]);
    return result as any;
  }

  eccNewPippenger(points: Uint8Array, numPointsBuf: number): Ptr {
    const result = this.binder.callWasmExport('ecc_new_pippenger', [points, numPointsBuf], [Ptr]);
    return result[0];
  }

  eccNewPippengerMemPrealloced(points: Ptr, numPoints: number): Ptr {
    const result = this.binder.callWasmExport('ecc_new_pippenger_mem_prealloced', [points, numPoints], [Ptr]);
    return result[0];
  }

  eccDeletePippenger(pippenger: Ptr): void {
    const result = this.binder.callWasmExport('ecc_delete_pippenger', [pippenger], []);
    return;
  }

  eccPippengerUnsafe(pippengerPtr: Ptr, scalarsPtr: Ptr, from: number, range: number): Point {
    const result = this.binder.callWasmExport('ecc_pippenger_unsafe', [pippengerPtr, scalarsPtr, from, range], [Point]);
    return result[0];
  }

  eccG1Sum(pointsPtr: Ptr, numPoints: number): Point {
    const result = this.binder.callWasmExport('ecc_g1_sum', [pointsPtr, numPoints], [Point]);
    return result[0];
  }

  examplesSimpleCreateAndVerifyProof(pippenger: Ptr, g2x: Uint8Array): boolean {
    const result = this.binder.callWasmExport('examples_simple_create_and_verify_proof', [pippenger, g2x], [BoolDeserializer()]);
    return result[0];
  }

  testThreads(threads: number, iterations: number): number {
    const result = this.binder.callWasmExport('test_threads', [threads, iterations], [NumberDeserializer()]);
    return result[0];
  }

  testThreadAbort(): void {
    const result = this.binder.callWasmExport('test_thread_abort', [], []);
    return;
  }

  testAbort(): void {
    const result = this.binder.callWasmExport('test_abort', [], []);
    return;
  }

  commonInitSlabAllocator(circuitSize: number): void {
    const result = this.binder.callWasmExport('common_init_slab_allocator', [circuitSize], []);
    return;
  }

  acirNewAcirComposer(pippenger: Ptr, g2x: Uint8Array): Ptr {
    const result = this.binder.callWasmExport('acir_new_acir_composer', [pippenger, g2x], [Ptr]);
    return result[0];
  }

  acirDeleteAcirComposer(acirComposerPtr: Ptr): void {
    const result = this.binder.callWasmExport('acir_delete_acir_composer', [acirComposerPtr], []);
    return;
  }

  acirInitProvingKey(acirComposerPtr: Ptr, constraintSystemBuf: Uint8Array, sizeHint: number): void {
    const result = this.binder.callWasmExport('acir_init_proving_key', [acirComposerPtr, constraintSystemBuf, sizeHint], []);
    return;
  }

  acirCreateProof(acirComposerPtr: Ptr, constraintSystemBuf: Uint8Array, witnessBuf: Uint8Array, isRecursive: boolean): Uint8Array {
    const result = this.binder.callWasmExport('acir_create_proof', [acirComposerPtr, constraintSystemBuf, witnessBuf, isRecursive], [BufferDeserializer()]);
    return result[0];
  }

  acirInitVerificationKey(acirComposerPtr: Ptr): void {
    const result = this.binder.callWasmExport('acir_init_verification_key', [acirComposerPtr], []);
    return;
  }

  acirVerifyProof(acirComposerPtr: Ptr, proofBuf: Uint8Array, isRecursive: boolean): boolean {
    const result = this.binder.callWasmExport('acir_verify_proof', [acirComposerPtr, proofBuf, isRecursive], [BoolDeserializer()]);
    return result[0];
  }

  acirGetSolidityVerifier(acirComposerPtr: Ptr): string {
    const result = this.binder.callWasmExport('acir_get_solidity_verifier', [acirComposerPtr], [StringDeserializer()]);
    return result[0];
  }

  acirGetExactCircuitSize(acirComposerPtr: Ptr): number {
    const result = this.binder.callWasmExport('acir_get_exact_circuit_size', [acirComposerPtr], [NumberDeserializer()]);
    return result[0];
  }

  acirGetTotalCircuitSize(acirComposerPtr: Ptr): number {
    const result = this.binder.callWasmExport('acir_get_total_circuit_size', [acirComposerPtr], [NumberDeserializer()]);
    return result[0];
  }

  acirVerifyRecursiveProof(acirComposerPtr: Ptr, proofBuf: Uint8Array, numInnerPublicInputs: number): Uint8Array {
    const result = this.binder.callWasmExport('acir_verify_recursive_proof', [acirComposerPtr, proofBuf, numInnerPublicInputs], [BufferDeserializer()]);
    return result[0];
  }

  acirSerializeProofIntoFields(acirComposerPtr: Ptr, proofBuf: Uint8Array, numInnerPublicInputs: number): Uint8Array {
    const result = this.binder.callWasmExport('acir_serialize_proof_into_fields', [acirComposerPtr, proofBuf, numInnerPublicInputs], [BufferDeserializer()]);
    return result[0];
  }

  acirSerializeVerificationKeyIntoFields(acirComposerPtr: Ptr): [Uint8Array, Uint8Array] {
    const result = this.binder.callWasmExport('acir_serialize_verification_key_into_fields', [acirComposerPtr], [BufferDeserializer(), BufferDeserializer()]);
    return result as any;
  }
}
