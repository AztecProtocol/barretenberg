/**
 * Generate TypeScript bindings from msgpack schema
 */

import { writeFileSync, mkdirSync } from 'fs';
import { dirname, join } from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import { fileURLToPath } from 'url';
import { unpack } from 'msgpackr';
import {
  createSharedTypesCompiler,
  createSyncApiCompiler,
  createAsyncApiCompiler,
  type SchemaCompiler,
} from './schema_compiler.js';

const execAsync = promisify(exec);

interface GeneratorConfig {
  name: string;
  outputFile: string;
  createCompiler: () => SchemaCompiler;
}

const GENERATORS: GeneratorConfig[] = [
  {
    name: 'Shared types',
    outputFile: 'generated/api_types.ts',
    createCompiler: createSharedTypesCompiler,
  },
  {
    name: 'Sync API',
    outputFile: 'generated/sync.ts',
    createCompiler: createSyncApiCompiler,
  },
  {
    name: 'Async API',
    outputFile: 'generated/async.ts',
    createCompiler: createAsyncApiCompiler,
  },
];

// @ts-ignore
const __dirname = dirname(fileURLToPath(import.meta.url));

async function generate() {
  const bbBuildPath = process.env.BB_BINARY_PATH || join(__dirname, '../../../cpp/build/bin/bb');

  // Get schema from bb
  console.log('Fetching msgpack schema from bb...');
  const { stdout } = await execAsync(`${bbBuildPath} msgpack schema`);
  const schema = JSON.parse(stdout.trim());

  if (!schema.commands || !schema.responses) {
    throw new Error('Invalid schema: missing commands or responses');
  }

  console.log('Generating TypeScript bindings...\n');

  // Ensure output directory exists
  const outputDir = join(__dirname, 'generated');
  mkdirSync(outputDir, { recursive: true });

  // Generate each output file
  for (const config of GENERATORS) {
    const compiler = config.createCompiler();
    compiler.processApiSchema(schema.commands, schema.responses);

    const outputPath = join(__dirname, config.outputFile);
    const content = compiler.compile();
    writeFileSync(outputPath, content);

    console.log(`✓ ${config.name}: ${outputPath}`);
  }

  // Generate curve constants
  console.log('\nGenerating curve constants...');
  await generateCurveConstants(bbBuildPath, outputDir);

  console.log('\nGeneration complete!');
}

async function generateCurveConstants(bbBuildPath: string, outputDir: string) {
  // Get curve constants from bb as msgpack binary
  const { stdout: constantsBuffer } = await execAsync(`${bbBuildPath} msgpack curve_constants`, {
    encoding: 'buffer',
    maxBuffer: 10 * 1024 * 1024, // 10MB buffer
  });

  // Decode msgpack
  const constants = unpack(constantsBuffer as Buffer);

  // Helper to convert Uint8Array to hex string
  const toHex = (bytes: Uint8Array) => '0x' + Buffer.from(bytes).toString('hex');

  // Helper to convert Uint8Array to bigint (big-endian)
  const toBigInt = (bytes: Uint8Array) => {
    let result = 0n;
    for (const byte of bytes) {
      result = (result << 8n) | BigInt(byte);
    }
    return result;
  };

  // Helper to serialize point coordinate (handles both Uint8Array and array of Uint8Array for field2)
  const serializeCoordinate = (coord: Uint8Array | Uint8Array[]) => {
    if (Array.isArray(coord)) {
      // For field2 (like BN254 G2), we have array of two Uint8Arrays
      return `[${coord.map(c => `new Uint8Array([${Array.from(c).join(', ')}])`).join(', ')}]`;
    } else {
      // For regular fields, single Uint8Array
      return `new Uint8Array([${Array.from(coord).join(', ')}])`;
    }
  };

  // Generate TypeScript file
  const content = `/**
 * Curve constants generated from barretenberg native binary.
 * DO NOT EDIT - This file is auto-generated by generate.ts
 */

/**
 * BN254 curve constants
 */
export const BN254_FR_MODULUS = ${toBigInt(constants.bn254_fr_modulus)}n;
export const BN254_FQ_MODULUS = ${toBigInt(constants.bn254_fq_modulus)}n;

export const BN254_G1_GENERATOR = {
  x: ${serializeCoordinate(constants.bn254_g1_generator.x)},
  y: ${serializeCoordinate(constants.bn254_g1_generator.y)},
} as const;

export const BN254_G2_GENERATOR = {
  x: ${serializeCoordinate(constants.bn254_g2_generator.x)},
  y: ${serializeCoordinate(constants.bn254_g2_generator.y)},
} as const;

/**
 * Grumpkin curve constants
 */
export const GRUMPKIN_FR_MODULUS = ${toBigInt(constants.grumpkin_fr_modulus)}n;
export const GRUMPKIN_FQ_MODULUS = ${toBigInt(constants.grumpkin_fq_modulus)}n;

export const GRUMPKIN_G1_GENERATOR = {
  x: ${serializeCoordinate(constants.grumpkin_g1_generator.x)},
  y: ${serializeCoordinate(constants.grumpkin_g1_generator.y)},
} as const;

/**
 * Secp256k1 curve constants
 */
export const SECP256K1_FR_MODULUS = ${toBigInt(constants.secp256k1_fr_modulus)}n;
export const SECP256K1_FQ_MODULUS = ${toBigInt(constants.secp256k1_fq_modulus)}n;

export const SECP256K1_G1_GENERATOR = {
  x: ${serializeCoordinate(constants.secp256k1_g1_generator.x)},
  y: ${serializeCoordinate(constants.secp256k1_g1_generator.y)},
} as const;

/**
 * Secp256r1 curve constants
 */
export const SECP256R1_FR_MODULUS = ${toBigInt(constants.secp256r1_fr_modulus)}n;
export const SECP256R1_FQ_MODULUS = ${toBigInt(constants.secp256r1_fq_modulus)}n;

export const SECP256R1_G1_GENERATOR = {
  x: ${serializeCoordinate(constants.secp256r1_g1_generator.x)},
  y: ${serializeCoordinate(constants.secp256r1_g1_generator.y)},
} as const;
`;

  const outputPath = join(outputDir, 'curve_constants.ts');
  writeFileSync(outputPath, content);
  console.log(`✓ Curve constants: ${outputPath}`);
}

// Run the generator
generate().catch(error => {
  console.error('Generation failed:', error);
  process.exit(1);
});
